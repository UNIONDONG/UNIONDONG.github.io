[{"id":0,"href":"/docs/linux/linux_api/","title":"Linux API 揭秘","section":"Linux开发","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":1,"href":"/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/","title":"【Linux API 揭秘】module_init与module_exit","section":"Linux API 揭秘","content":" Linux Version：6.6\nAuthor：Donge\nGithub：linux-api-insides\n  1、函数作用 #  module_init和module_exit是驱动中最常用的两个接口，主要用来注册、注销设备驱动程序。\n并且这两个接口的实现机制是一样的，我们先以module_init为切入点分析。\n 2、module_init函数解析 #  2.1 module_init #  #ifndef MODULE /** * module_init() - driver initialization entry point * @x: function to be run at kernel boot time or module insertion * * module_init() will either be called during do_initcalls() (if * builtin) or at module insertion time (if a module). There can only * be one per module. */ #define module_init(x)\t__initcall(x);  ...... #else /* MODULE */ ...... /* Each module must use one module_init(). */ #define module_init(initfn)\t\\ static inline initcall_t __maybe_unused __inittest(void)\t\\ { return initfn; }\t\\ int init_module(void) __copy(initfn)\t\\ __attribute__((alias(#initfn)));\t\\ ___ADDRESSABLE(init_module, __initdata);  ...... #endif 函数名称：module_init\n文件位置：include/linux/module.h\n函数解析：\n 在Linux内核中，驱动程序可以以两种方式存在：内建(Builtin)和模块(Module)。内建驱动就是在编译时，直接编译进内核镜像中；而模块驱动则是在内核运行过程中动态加载卸载的。\n module_init函数的定义位置有两处，使用MODULE宏作为判断依据。MODULE是一个预处理器宏，仅当该驱动作为模块驱动时，编译的时候会加入MODULE的定义。\n 这里难免会有疑问：为什么会有两套实现呢？\n 其实，当模块被编译进内核时，代码是存放在内存的.init字段，该字段在内核代码初始化后，就会被释放掉了，所以当可动态加载模块需要加载时，就需要重新定义了。\n 2.1.1 模块方式 #  当驱动作为可加载模块时，MODULE宏被定义，我们简单分析一下相关代码\n#define module_init(initfn)\t\\ static inline initcall_t __maybe_unused __inittest(void)\t\\ { return initfn; }\t\\ int init_module(void) __copy(initfn)\t\\ __attribute__((alias(#initfn)));\t\\ ___ADDRESSABLE(init_module, __initdata);  static inline initcall_t __maybe_unused __inittest(void) { return initfn; }：一个内联函数，返回传入的initfn函数。  __maybe_unused ：编译器指令，用于告诉编译器，该函数可能不会使用，以避免编译器产生警告信息。   int init_module(void) __copy(initfn) __attribute__((alias(#initfn)));：init_module函数的声明  __copy(initfn)：编译器指令，也就是将我们的initfn函数代码复制到init_module中， __attribute__((alias(#initfn)))：编译器指令，将init_module函数符号的别名设置为initfn。   ___ADDRESSABLE(init_module, __initdata);：一个宏定义，主要用于将init_module函数的地址放入__initdata段，这样，当模块被加载时，init_module函数的地址就可以被找到并调用。  总的来说，如果是可加载的ko模块，module_init宏主要定义了init_module函数，并且将该函数与initfn函数关联起来，使得当模块被加载时，初始化函数可以被正确地调用。\n 2.1.2 内建方式 #  当模块编译进内核时，MODULE宏未被定义，所以走下面流程\n#define module_init(x)\t__initcall(x);  2.2 __initcall #  #define __initcall(fn) device_initcall(fn)  #define device_initcall(fn)\t__define_initcall(fn, 6)  #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)  #define ___define_initcall(fn, id, __sec)\t\\ __unique_initcall(fn, id, __sec, __initcall_id(fn))  #define __unique_initcall(fn, id, __sec, __iid)\t\\ ____define_initcall(fn,\t\\ __initcall_stub(fn, __iid, id),\t\\ __initcall_name(initcall, __iid, id),\t\\ __initcall_section(__sec, __iid))  #define ____define_initcall(fn, __unused, __name, __sec)\t\\ static initcall_t __name __used \\ __attribute__((__section__(__sec))) = fn;  #define __initcall_stub(fn, __iid, id)\tfn  /* Format: \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt; */ #define __initcall_id(fn)\t\\ __PASTE(__KBUILD_MODNAME,\t\\ __PASTE(__,\t\\ __PASTE(__COUNTER__,\t\\ __PASTE(_,\t\\ __PASTE(__LINE__,\t\\ __PASTE(_, fn))))))  /* Format: __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt; */ #define __initcall_name(prefix, __iid, id)\t\\ __PASTE(__,\t\\ __PASTE(prefix,\t\\ __PASTE(__,\t\\ __PASTE(__iid, id))))  #define __initcall_section(__sec, __iid)\t\\ #__sec \u0026#34;.init\u0026#34;  /* Indirect macros required for expanded argument pasting, eg. __LINE__. */ #define ___PASTE(a,b) a##b #define __PASTE(a,b) ___PASTE(a,b) 函数名称：__initcall\n文件位置：include/linux/init.h\n函数解析：设备驱动初始化函数\n 2.2.1 代码调用流程 #  module_init(fn) |--\u0026gt; __initcall(fn) |--\u0026gt; device_initcall(fn) |--\u0026gt; __define_initcall(fn, 6) |--\u0026gt; ___define_initcall(fn, id, __sec) |--\u0026gt; __initcall_id(fn) |--\u0026gt; __unique_initcall(fn, id, __sec, __iid) |--\u0026gt; ____define_initcall(fn, __unused, __name, __sec) |--\u0026gt; __initcall_stub(fn, __iid, id) |--\u0026gt; __initcall_name(prefix, __iid, id) |--\u0026gt; __initcall_section(__sec, __iid) |--\u0026gt; ____define_initcall(fn, __unused, __name, __sec)   进行函数分析前，我们先要明白#和##的概念\n 2.2.2 #和##的作用 #     符号 作用 举例     ## ##符号 可以是连接的意思 例如 __initcall_##fn##id 为__initcall_fnid那么，fn = test_init，id = 6时，__initcall##fn##id 为 __initcall_test_init6   # #符号 可以是字符串化的意思 例如 #id 为 \u0026quot;id\u0026quot;，id=6 时，#id 为\u0026quot;6\u0026quot;      更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2.2.3 函数解析 #   下面分析理解比较有难度的函数\n #define device_initcall(fn)\t__define_initcall(fn, 6) #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)  .initcall##id：通过##来拼接两个字符串：.initcall6  #define ___define_initcall(fn, id, __sec)\t\\ __unique_initcall(fn, id, __sec, __initcall_id(fn))  /* Format: \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt; */ #define __initcall_id(fn)\t\\ __PASTE(__KBUILD_MODNAME,\t\\ __PASTE(__,\t\\ __PASTE(__COUNTER__,\t\\ __PASTE(_,\t\\ __PASTE(__LINE__,\t\\ __PASTE(_, fn))))))  /* Indirect macros required for expanded argument pasting, eg. __LINE__. */ #define ___PASTE(a,b) a##b #define __PASTE(a,b) ___PASTE(a,b)  ___PASTE：拼接两个字符串 __initcall_id：它用于生成一个唯一的标识符，这个标识符用于标记初始化函数。  __KBUILD_MODNAME：当前正在编译的模块的名称 __COUNTER__：一个每次使用都会递增计数器，用于确保生成名称的唯一性 __LINE__：当前代码的行号     #define __unique_initcall(fn, id, __sec, __iid)\t\\ ____define_initcall(fn,\t\\ __initcall_stub(fn, __iid, id),\t\\ __initcall_name(initcall, __iid, id),\t\\ __initcall_section(__sec, __iid))  #define ____define_initcall(fn, __unused, __name, __sec)\t\\ static initcall_t __name __used \\ __attribute__((__section__(__sec))) = fn;  #define __initcall_stub(fn, __iid, id)\tfn  /* Format: __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt; */ #define __initcall_name(prefix, __iid, id)\t\\ __PASTE(__,\t\\ __PASTE(prefix,\t\\ __PASTE(__,\t\\ __PASTE(__iid, id))))  #define __initcall_section(__sec, __iid)\t\\ #__sec \u0026#34;.init\u0026#34; __unique_initcall：调用____define_initcall，关键实现部分\n____define_initcall：定义一个名为 __name 的 initcall_t 类型的静态变量，并将其初始化为 fn，并放入特定的__sec段中。\n __initcall_stub：表示唯一的函数名fn __initcall_name：表示一个唯一的变量名 __initcall_section： 生成一个唯一的段名。 #__sec \u0026quot;.init\u0026quot;：将两个字符串拼接起来，比如：__sec=.initcall6，拼接后的段为：.initcall6.init，该段为最终存储的段。   字段通过链接器链接起来，形成一个列表进行统一管理。\n 这些字段我们可以在arch/arm/kernel/vmlinux.lds中查看。\n ...... __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init)) ......  3、module_exit函数解析 #   module_exit和module_init的实现机制几乎没有差别，下面就简单介绍一下。\n 3.1 module_exit #  #ifndef MODULE  /** * module_exit() - driver exit entry point * @x: function to be run when driver is removed * * module_exit() will wrap the driver clean-up code * with cleanup_module() when used with rmmod when * the driver is a module. If the driver is statically * compiled into the kernel, module_exit() has no effect. * There can only be one per module. */ #define module_exit(x)\t__exitcall(x);  ...... #else /* MODULE */ ...... /* This is only required if you want to be unloadable. */ #define module_exit(exitfn)\t\\ static inline exitcall_t __maybe_unused __exittest(void)\t\\ { return exitfn; }\t\\ void cleanup_module(void) __copy(exitfn)\t\\ __attribute__((alias(#exitfn)));\t\\ ___ADDRESSABLE(cleanup_module, __exitdata);  ...... #endif 函数名称：module_exit\n文件位置：include/linux/module.h\n3.1.1 模块方式 #  作为模块方式，与module_init的实现方式一样，定义cleanup_module与exitfn函数相关联，存放在__exitdata段内。\n 3.1.2 内建方式 #  当模块编译进内核时，MODULE宏未被定义，所以走下面流程\n#define module_exit(x)\t__exitcall(x);  3.2 __exitcall #  #define __exitcall(fn)\t\\ static exitcall_t __exitcall_##fn __exit_call = fn  #define __exit_call\t__used __section(\u0026#34;.exitcall.exit\u0026#34;) 函数名称：__initcall\n文件位置：include/linux/init.h\n函数解析：设备驱动卸载函数\n__exitcall_##fn：定义一个新的 exitcall_t 类型的静态变量，并赋值为fn\n__exit_call：__used __section(\u0026quot;.exitcall.exit\u0026quot;)，定义该函数存储的段\n 4、扩展 #   还记得__define_initcall的定义吗？\n #define pure_initcall(fn) __define_initcall(fn, 0)  #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s)  #define __initcall(fn) device_initcall(fn) 不同的宏定义，被赋予了不同的调用等级，最后将不同的驱动初始化函数统一汇总到__initcallx_start字段统一管理，形成一个有序的列表。\n这样，我们在内核中，按照顺序遍历这个列表，最后执行对应的模块初始化函数fn即可实现驱动的初始化。\n"},{"id":2,"href":"/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/","title":"一、uboot基础了解","section":"Uboot开发","content":"一、uboot基础了解 #  1. U-boot是什么 #  U-Boot，全称 Universal Boot Loader，是遵循GPL条款的从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的 开放源码项目。\nU-boot，是一个主要用于嵌入式系统的引导加载程序，可以支持多种不同的计算机系统结构，其主要作用为：==引导系统的启动！==目前，U-Boot不仅支持Linux系统的引导，还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android等多种嵌入式操作系统。\n2. U-boot主要特性及功能 #   开放：开放的源代码 多平台：支持多种嵌入式操作系统，如Linux、NetBSD、android等 生态：有丰富的设备驱动源码，如以太网、SDRAM、LCD等，同时也具有丰富的开发文档。  3. U-boot下载地址 #  Uboot开发源码：\n  https://source.denx.de/u-boot/u-boot\n  https://ftp.denx.de/pub/u-boot/\n  其他厂商定制的uboot源码：\n 野火  4. U-boot目录结构 #     目录 含义     arch 各个厂商的硬件信息，目录下包括支持的处理器类型   arch/arm/cpu/xxx **每一个子文件夹，包含一种cpu系列。**每个子文件夹下包含cpu.c（CPU初始化），interrupts.c（设置中断和异常），start.S（U-boot的启动文件，早期的初始化）。   board 与开发板有关，每一个子文件夹代表一个芯片厂家，芯片厂家下，每一个子文件夹，表示一个开发板   common 存放与处理器体系无关的通用代码，可以说为通用核心代码！   cmd 存放uboot的相关命令实现部分   drivers 存放外围芯片驱动，网卡，USB等   disk 存放驱动磁盘的分区处理代码   fs 本目录下存放文件系统相关代码，每一个子文件夹表示文件系统   net 网络协议相关代码   doc uboot说明文档   include 各种头文件   post 上电自检代码   api 外部扩展程序的API和示例   tools 编译S-Record或者U-boot镜像的相关工具    5. 如何编译Uboot #  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean make ARCH=arm CORSS_COMPILE=arm-linux-gnueabihf- colibri-imx6ull_defconfig make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 ARCH=arm：arm架构\nCROSS_COMPILE：使用的交叉编译器\n 如果编译出错，your compile older 6.0，可以参考【1】\n colibri-imx6ull_defconfig：指定一个config文件，作为相关版型的配置信息\nV=1：这个选项能显示出编译过程中的详细信息，即是verbose编译模式\n-j8：多核并行编译，可以提高编译速度，受硬件限制\n6. U-boot工作模式 #   U-boot的工作模式有：启动加载模式和下载模式\n  启动加载模式：  启动加载模式，为Bootloader正常工作模式，一款开发板，正常上电后，Bootloader将嵌入式操作系统==从FLASH中加载到SDRAM中==运行。\n 下载模式：  下载模式，就是Bootloader通过通信，将内核镜像、根文件系统镜像从PC机直接下载到目标板的FLASH中。\n7. U-boot的存放位置 #  嵌入式系统，一般使用Flash来作为启动设备，Flash上存储着U-boot、环境变量、内核映像、文件系统等。U-boot存放于Flash的起始地址，所在扇区由Soc规定。\n8. U-boot系列文章汇总 #   下面是进行U-boot开发期间，感觉比较不错的资料，总结分享一下！\n [1] : Uboot官网、Uboot官方指南、官方指南2\n[2] : https://blog.51cto.com/u_9291927/category5\n[3] : https://blog.csdn.net/ooonebook/category_6484145.html\n[4]：https://blog.csdn.net/qq_36310253/category_9332618.html\n"},{"id":3,"href":"/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/","title":"Soc的Bring Up流程","section":"嵌入式面经","content":"1、Bring Up流程 #  SOC (System on a Chip) bring-up是一个复杂的过程，涉及到硬件、固件和软件的集成和验证，以下是一个基于BROM，SPL，UBOOT和Linux的启动流程的概述：\n BROM (Boot Read-Only Memory)启动：启动的最初阶段，在这个阶段，系统会执行芯片ROM里面的代码，这部分代码主要用来检查启动模式，包括NOR、Nand、Emmc等，然后从对应的存储介质中加载SPL(Secondary Program Loader)代码。 SPL (Secondary Program Loader)启动：SPL属于Uboot的一部分，它的主要作用就是：初始化硬件并加载完整的U-boot，主要体现在初始化时钟、看门狗、DDR、GPIO以及存储外设，最后将U-boot代码加载到DDR中执行。 U-Boot启动：U-boot的主要作用是：引导加载Kernel和DTS。U-boot在启动之后，同样初始化Soc硬件资源，然后会计时等待，并执行默认的启动命令，将Kernel和DTS信息从存储介质中读取出来并加载到内存中执行。 Kernel启动：在U-Boot加载了内核映像和设备树之后，系统会启动Linux。在这个阶段，系统会初始化各种硬件设备，加载驱动程序并启动用户空间应用程序。   更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2、常见问题 #  Q：为什么上一个阶段已经初始化了硬件资源，下一个阶段为何重复初始化？\nA：\n  每个阶段的硬件初始化，其目标和需求都不同，硬件配置也会不一样，因此在不同阶段进行不同的初始化。\n  硬件状态可能会改变，在SOC启动过程中，硬件状态可能会因为电源管理、时钟管理等原因而改变，这可能需要在每个阶段都重新初始化以确保其正确工作\n  为了保证硬件资源的可靠性，最好每个阶段都重新初始化一次\n   Q：U-boot加载内核时，会进行重定位的操作，这一操作有何意义？\nA：\n U-boot的重定位，主要作用是为了 给内核提供一个连续的、大的内存空间，供内核和其他应用程序使用 U-boot的加载过程分两个阶段，即：SPL和U-boot，   在SPL阶段，主要将U-boot代码从Flash中加载到RAM指定位置 在U-boot阶段，U-boot会将自身从RAM的开始部分移动到RAM的末尾，占用高地址空间，从而让低地址空间可以作为一个连续的，大的内存空间供内核和其他应用程序使用。   Q：在Bring Up中，为了保证启动时间，如何裁剪？\nA：\n 启动时间的裁剪是一个重要的步骤，其主要目标是缩短从电源打开到操作系统完全启动的时间。\n  优化Bootloader：减小Bootloader的代码大小，减少硬件初始化（只初始化必要硬件设备）等 优化Kernel：减少启动服务数量，优化服务的启动顺序，使用预加载技术等方法来实现。 使用快速启动模式：一些SOC支持快速启动模式，这种模式下，SOC会跳过一些不必要的硬件初始化和自检过程，从而更快地启动。 使用休眠和唤醒技术：一些SOC还支持休眠和唤醒技术，这种技术可以将系统的状态保存到非易失性存储器中，然后关闭系统。当系统再次启动时，可以直接从非易失性存储器中恢复系统的状态，从而更快地启动。   "},{"id":4,"href":"/docs/embeded_tech/self_improve/","title":"嵌入式工程师养成记","section":"嵌入式","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":5,"href":"/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","title":"【Linux API 揭秘】container_of函数详解","section":"Linux API 揭秘","content":" Linux Version：6.6\nAuthor：Donge\nGithub：linux-api-insides\n  1、container_of函数介绍 #  container_of可以说是内核中使用最为频繁的一个函数了，简单来说，它的主要作用就是根据我们结构体中的已知的成员变量的地址，来寻求该结构体的首地址，直接看图，更容易理解。\n 下面我们看看linux是如何实现的吧\n 2、container_of函数实现 #  /** * container_of - cast a member of a structure out to the containing structure * @ptr:\tthe pointer to the member. * @type:\tthe type of the container struct this is embedded in. * @member:\tthe name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */ #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ static_assert(__same_type(*(ptr), ((type *)0)-\u0026gt;member) ||\t\\ __same_type(*(ptr), void),\t\\ \u0026#34;pointer type mismatch in container_of()\u0026#34;);\t\\ ((type *)(__mptr - offsetof(type, member))); })  函数名称：container_of\n文件位置：include/linux/container_of.h\n该函数里面包括了一些封装好的宏定义以及函数，比如：static_assert、__same_type、offsetof，以及一些指针的特殊用法，比如：(type *)0)，下面我们一一拆解来看。\n2.1 static_assert #  /** * static_assert - check integer constant expression at build time * * static_assert() is a wrapper for the C11 _Static_assert, with a * little macro magic to make the message optional (defaulting to the * stringification of the tested expression). * * Contrary to BUILD_BUG_ON(), static_assert() can be used at global * scope, but requires the expression to be an integer constant * expression (i.e., it is not enough that __builtin_constant_p() is * true for expr). * * Also note that BUILD_BUG_ON() fails the build if the condition is * true, while static_assert() fails the build if the expression is * false. */ #define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr) #define __static_assert(expr, msg, ...) _Static_assert(expr, msg) 函数名称：static_assert\n文件位置：include/linux/build_bug.h\n函数解析：该宏定义主要用来 在编译时检查常量表达式，如果表达式为假，编译将失败，并打印传入的报错信息 expr：该参数表示传入进来的常量表达式 ...：表示编译失败后，要打印的错误信息 _Static_assert：C11中引入的关键字，用于判断表达式expr并打印错误信息msg。  在container_of函数中，主要用来断言判断\nstatic_assert( __same_type(*(ptr), ((type *)0)-\u0026gt;member) || __same_type(*(ptr), void) , \u0026#34;pointer type mismatch in container_of()\u0026#34; );  2.2 __same_type #  /* Are two types/vars the same type (ignoring qualifiers)? */ #ifndef __same_type # define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b)) #endif 函数名称：__same_type\n文件位置：include/linux/compiler.h\n函数解析：该宏定义用于检查两个变量是否是同种类型 __builtin_types_compatible_p：gcc的内建函数，判断两个参数的类型是否一致，如果是则返回1 typeof：gcc的关键字，用于获取变量的类型信息  了解完__same_type，想要理解__same_type(*(ptr), ((type *)0)-\u0026gt;member)，需要先弄明白(type *)0的含义。\n  更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2.3 (type *)0 #  (type *)0，该如何理解这个表达式呢？\n 首先，type是我们传入进来的结构体类型，比如上面讲到的struct test，而这里所做的可以理解为强制类型转换：(struct test *)addr。 addr可以表示内存空间的任意的地址，我们在强制转换后，默认后面一片的内存空间存储的是该数据结构。   而(type *)0的作用，也就是默认将0地址处的内存空间，转换为该数据类型。   我们就把0，当作我们正常的addr地址变量来操作，((type *)0)-\u0026gt;member，就是获取我们结构体的成员对象。 ((type *)0)-\u0026gt;member：是一种常见的技巧，用于直接获取结构体type的成员member的类型，而不需要定义一个type类型的对象。   2.4 offsetof #  #ifndef offsetof #define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #endif 函数名称：offsetof\n文件位置：include/linux/stddef.h\n函数解析：该宏定义用于获取结构体中指定的成员，距离该结构体偏移量。 TYPE：表示结构体的类型 MEMBER：表示指定的结构体成员 __builtin_offsetof：gcc内置函数，直接返回偏移量。   在新的linux源码中，直接引用了gcc内置的函数，而在老的内核源码中，该偏移量的实现方式如下：\n#define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) 同样用到了((TYPE *)addr)，上面我们知道\n ((TYPE *)addr)-\u0026gt;MEMBER：表示获取该结构体的成员 \u0026amp;((TYPE *)addr)-\u0026gt;MEMBER)：加了一个\u0026amp;，表示地址，取该成员的内存地址。  比如我们addr=0x00000010，那么\u0026amp;((TYPE *)0x00000010)-\u0026gt;MEMBER)就相当于0x00000010+size 比如我们addr=0，那么\u0026amp;((TYPE *)0)-\u0026gt;MEMBER)就相当于size     到这里，我们对container_of函数内部涉及的相关知识了然于胸，下面我们再来看container_of，简直容易到起飞。\n 2.5 container_of #  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ static_assert(__same_type(*(ptr), ((type *)0)-\u0026gt;member) ||\t\\ __same_type(*(ptr), void),\t\\ \u0026#34;pointer type mismatch in container_of()\u0026#34;);\t\\ ((type *)(__mptr - offsetof(type, member))); })  static_assert：断言信息，避免我们传入的参数类型不对，而做的编译检查处理，直接忽略。  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ ((type *)(__mptr - offsetof(type, member))); })   offsetof(type, member)：计算的是结构体中的成员的偏移量，这里称为size\n  (__mptr - offsetof(type, member))：也就是根据我们已知的成员变量地址，计算出来结构体的首地址\n  ((type *)(__mptr - offsetof(type, member)))：最后强制转换为(type *)，结构体指针。\n   比如，我们已知的结构体成员的地址为0xffff0000，计算之后如下：\n 3、总结 #  linux内核中，小小的一个函数，内部包括的技巧如此之多：static_assert、__same_type、(type *)0、offsetof。\n了解完内部完整的实现手法之后，我们也可以手码一个container_of了 :)\n "},{"id":6,"href":"/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","title":"二、uboot启动流程分析","section":"Uboot开发","content":"二、uboot启动流程分析 #   上一篇文章：（一）uboot基础了解 下一篇文章：（三）Uboot驱动模型\n 同大多数的Bootloader一样，uboot的启动过程也分为BL1、BL2两个阶段，分别对应着SPL和Uboot。\nSPL（BL1阶段）：负责开发板的基础配置和设备初始化，并且搬运Uboot到内存中，由汇编代码和少量的C语言实现\nUboot（BL2阶段）：主要负责初始化外部设备，引导Kernel启动，由纯C语言实现。\n 我们这篇文章，主要介绍Uboot（BL2阶段）的启动流程，BL1阶段启动流程的详细分析，可以见我的后续文章。想要深入了解的，可以好好研究下！\n 2.1、程序执行流程图 #  我们先总体来看一下Uboot的执行步骤，这里以EMMC作为启动介质，进行分析！\n无论是哪种启动介质，基本流程都相似，我们这就往下看！\n==打开图片，结合文档、图片、代码进行理解！==\n 2.2、u-boot.lds——Uboot的入口函数 #  u-boot.lds：是uboot工程的链接脚本文件，对于工程的编译和链接有非常重要的作用，决定了uboot的组装，并且u-boot.lds链接文件中的ENTRY(_start)指定了uboot程序的入口地址。\n 如果不知道u-boot.lds放到在哪里，可以通过find -name u-boot.lds查找，根目录要进入到uboot的源码的位置哦！\n如果查找结果有很多，结合自己的板子信息，确定自己使用的u-boot.lds。\n当然，准确的方法是查看Makefile文件，分析出来u-boot.lds所生成的位置。\n 在u-boot.lds的文件中，可以看到.text段，存放的就是执行的文本段。截取部分代码段如下：\nOUTPUT_FORMAT(\u0026#34;elf32-littlearm\u0026#34;, \u0026#34;elf32-littlearm\u0026#34;, \u0026#34;elf32-littlearm\u0026#34;) OUTPUT_ARCH(arm) ENTRY(_start) SECTIONS { . = 0x00000000;\t@起始地址  . = ALIGN(4);\t@四字节对齐  .text :\t{\t*(.__image_copy_start)\t@映像文件复制起始地址 *(.vectors)\t@异常向量表 arch/arm/cpu/armv7/start.o (.text*)\t@启动函数 } ...... }   ENTRY(_start)：程序的入口函数，_start在arch/arm/lib/vectors.S中定义.globl _start\n  SECTIONS定义了段，包括text文本段、data数据段、bss段等。\n  __image_copy_start在System.map和u-boot.map中均有定义\n  arch/arm/cpu/armv7/start.o对应文件arch/arm/cpu/armv7/start.S，该文件中定义了main函数的入口。\n   Tip：上面只进行大概分析，有汇编经验的朋友，可以详细进行分析！\n 2.3、board_init_f——板级前置初始化 #  跟随上文的程序执行流程图，我们看board_init_f这个函数。其位于common/board_f.c。\nvoid board_init_f(ulong boot_flags) { gd-\u0026gt;flags = boot_flags; gd-\u0026gt;have_console = 0; if (initcall_run_list(init_sequence_f)) hang(); } static const init_fnc_t init_sequence_f[] = { setup_mon_len, ... log_init, arch_cpu_init,\t/* basic arch cpu dependent setup */ env_init,\t/* initialize environment */ ... reloc_fdt, reloc_bootstage, reloc_bloblist, setup_reloc, ... } board_init_f()，其最核心的内容就是调用了init_sequence_f初始化序列，进行了一系列初始化的工作。\n主要包括：串口、定时器、设备树、DM驱动模型等，另外还包括global_data结构体相关对象的变量。\n 详细分析，可以看文末的参考文章[1]\n 我们需要注意的一点就是，在初始化队列末尾，执行了几个reloc_xxx的函数，这几个函数实现了Uboot的重定向功能。\n2.4、relocate_code重定向 #   重定向技术，可以说也算是Uboot的一个重点了，也就是将uboot自身镜像拷贝到ddr上的另外一个位置的动作。\n 2.4.1 为什么需要重定向呢？ #   一般需要重定向的条件如下：\n  uboot存储在只读存储器上，比如ROM、Nor flash，需要将代码拷贝到DDR上，才能完整运行Uboot。 为Kernel腾空间，Kernel一般会放在DDR的地段地址上，所以要把Uboot重定向到顶端地址，避免冲突。  2.4.2 Uboot是如何重定向的？ #  Uboot的重定向有如下几个步骤：\n 对relocate进行空间划分 计算uboot代码空间到relocate的位置的偏移 relocate旧的global_data到新的global_data空间上 relocate Uboot 修改relocate后的全局变量的label relocate中断向量表  运行大致流程：\narch/arm/lib/crt0.S文件内，主要实现了：\nENTRY(_main) bl board_init_f @@ 在board_init_f里面实现了 @@ （1）对relocate进行空间规划 @@ （2）计算uboot代码空间到relocation的位置的偏移 @@ （3）relocate旧的global_data到新的global_data的空间上 ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-\u0026gt;start_addr_sp */  bic sp, sp, #7 /* 8-byte alignment for ABI compliance */  ldr r9, [r9, #GD_BD] /* r9 = gd-\u0026gt;bd */  sub r9, r9, #GD_SIZE /* new GD is below bd */ @@ 把新的global_data地址放在r9寄存器中 adr lr, here ldr r0, [r9, #GD_RELOC_OFF] /* r0 = gd-\u0026gt;reloc_off */  add lr, lr, r0 @@ 计算返回地址在新的uboot空间中的地址。b调用函数返回之后，就跳到了新的uboot代码空间中。 ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u0026gt;relocaddr */ @@ 把uboot的新的地址空间放到r0寄存器中，作为relocate_code的参数 b relocate_code @@ 跳转到relocate_code中，在这里面实现了 @@ （1）relocate旧的uboot代码空间到新的空间上去 @@ （2）修改relocate之后全局变量的label @@ 注意，由于上述已经把lr寄存器重定义到uboot新的代码空间中了，所以返回之后，就已经跳到了新的代码空间了！！！！！！ bl relocate_vectors @@ relocate中断向量表  setup_reloc——重定向地址查看（仿真有关）  在这里我们说明一下board_init_f里面的setup_reloc初始化函数\nstatic int setup_reloc(void) { if (gd-\u0026gt;flags \u0026amp; GD_FLG_SKIP_RELOC) { debug(\u0026#34;Skipping relocation due to flag\\n\u0026#34;); return 0; } #ifdef CONFIG_SYS_TEXT_BASE #ifdef ARM  gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - (unsigned long)__image_copy_start; #elif defined(CONFIG_M68K)  /* * On all ColdFire arch cpu, monitor code starts always * just after the default vector table location, so at 0x400 */ gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - (CONFIG_SYS_TEXT_BASE + 0x400); #elif !defined(CONFIG_SANDBOX)  gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - CONFIG_SYS_TEXT_BASE; #endif #endif  memcpy(gd-\u0026gt;new_gd, (char *)gd, sizeof(gd_t)); debug(\u0026#34;Relocation Offset is: %08lx\\n\u0026#34;, gd-\u0026gt;reloc_off); if (is_debug_open()) { printf(\u0026#34;Relocating to %08lx, new gd at %08lx, sp at %08lx\\n\u0026#34;, gd-\u0026gt;relocaddr, (ulong)map_to_sysmem(gd-\u0026gt;new_gd), gd-\u0026gt;start_addr_sp); } return 0; } 由于，Uboot进行了重定向，所以按照常规的地址仿真的话，我们可能访问到错误的内存空间，通过setup_reloc的Relocating to %08lx打印，我们可以得到重定向后的地址，方便我们仿真。\nUboot的重定向也有相当大的一部分知识点，上面也仅仅是简单介绍了relocate的基本步骤和流程，后续看大家需要，如果大家想了解，我再补上这一部分。\n2.4.3 Uboot重定向作用 #  总之，Uboot重定向之后，把Uboot整体搬运到了高端内存区，为Kernel的加载提供空间，避免内存践踏。\n2.5、board_init_r——板级后置初始化 #   我们接着跟着流程图往下看，重定向之后，Uboot运行于新的地址空间，接着我们执行board_init_r，主要作为Uboot运行的最后初始化步骤。\n board_init_r这个函数，同样位于common/board_f.c，主要用于初始化各类外设信息\nvoid board_init_r(gd_t *new_gd, ulong dest_addr) {\tif (initcall_run_list(init_sequence_r)) hang(); /* NOTREACHED - run_main_loop() does not return */ hang(); } static init_fnc_t init_sequence_r[] = { initr_reloc, initr_reloc_global_data, board_init,\t/* Setup chipselects */ initr_dm, initr_mmc, ... run_main_loop } 与board_init_f相同，同样有一个init_sequence_r初始化列表，包括：initr_dmDM模型初始化，initr_mmcMMC驱动初始化，等等。\n最终，uboot就运行到了run_main_loop，进而执行main_loop这个函数。\n2.6、main_loop——Uboot主循环 #   该函数为Uboot的最终执行函数，无论是加载kernel还是uboot的命令行体系，均由此实现。\n void main_loop(void) { const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, \u0026#34;main_loop\u0026#34;); if (IS_ENABLED(CONFIG_VERSION_VARIABLE)) env_set(\u0026#34;ver\u0026#34;, version_string); /* set version variable */ cli_init(); if (IS_ENABLED(CONFIG_USE_PREBOOT)) run_preboot_environment_command(); if (IS_ENABLED(CONFIG_UPDATE_TFTP)) update_tftp(0UL, NULL, NULL); s = bootdelay_process(); if (cli_process_fdt(\u0026amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(\u0026#34;No CLI available\u0026#34;); } env_set：设置环境变量，两个参数分别为name和value\ncli_init：用于初始化hash shell的一些变量\nrun_preboot_environment_command：执行预定义的环境变量的命令\nbootdelay_process：加载延时处理，一般用于Uboot启动后，有几秒的倒计时，用于进入命令行模式。\ncli_loop：命令行模式，主要作用于Uboot的命令行交互。\n2.6.1 bootdelay_process #   记得对照文章开始的执行流程图哦！\n 详细解释标注于代码中\u0026hellip;\u0026hellip;\nconst char *bootdelay_process(void) { char *s; int bootdelay; bootcount_inc(); s = env_get(\u0026#34;bootdelay\u0026#34;);\t//先判断是否有bootdelay环境变量，如果没有，就使用menuconfig中配置的CONFIG_BOOTDELAY时间  bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY; if (IS_ENABLED(CONFIG_OF_CONTROL))\t//是否使用设备树进行配置  bootdelay = fdtdec_get_config_int(gd-\u0026gt;fdt_blob, \u0026#34;bootdelay\u0026#34;, bootdelay); debug(\u0026#34;### main_loop entered: bootdelay=%d\\n\\n\u0026#34;, bootdelay); if (IS_ENABLED(CONFIG_AUTOBOOT_MENU_SHOW)) bootdelay = menu_show(bootdelay); bootretry_init_cmd_timeout(); #ifdef CONFIG_POST  if (gd-\u0026gt;flags \u0026amp; GD_FLG_POSTFAIL) { s = env_get(\u0026#34;failbootcmd\u0026#34;); } else #endif /* CONFIG_POST */ if (bootcount_error()) s = env_get(\u0026#34;altbootcmd\u0026#34;); else s = env_get(\u0026#34;bootcmd\u0026#34;);\t//获取bootcmd环境变量，用于后续的命令执行  if (IS_ENABLED(CONFIG_OF_CONTROL)) process_fdt_options(gd-\u0026gt;fdt_blob); stored_bootdelay = bootdelay; return s; } 2.6.2 autoboot_command #  详细解释标注于代码中\u0026hellip;\u0026hellip;\nvoid autoboot_command(const char *s) { debug(\u0026#34;### main_loop: bootcmd=\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, s ? s : \u0026#34;\u0026lt;UNDEFINED\u0026gt;\u0026#34;); if (stored_bootdelay != -1 \u0026amp;\u0026amp; s \u0026amp;\u0026amp; !abortboot(stored_bootdelay)) { bool lock; int prev; lock = IS_ENABLED(CONFIG_AUTOBOOT_KEYED) \u0026amp;\u0026amp; !IS_ENABLED(CONFIG_AUTOBOOT_KEYED_CTRLC); if (lock) prev = disable_ctrlc(1); /* disable Ctrl-C checking */ run_command_list(s, -1, 0); if (lock) disable_ctrlc(prev);\t/* restore Ctrl-C checking */ } if (IS_ENABLED(CONFIG_USE_AUTOBOOT_MENUKEY) \u0026amp;\u0026amp; menukey == AUTOBOOT_MENUKEY) { s = env_get(\u0026#34;menucmd\u0026#34;); if (s) run_command_list(s, -1, 0); } } 我们看一下判断条件stored_bootdelay != -1 \u0026amp;\u0026amp; s \u0026amp;\u0026amp; !abortboot(stored_bootdelay\n stored_bootdelay：为环境变量的值，或者menuconfig设置的值 s：为环境变量bootcmd的值，为后续运行的指令 abortboot(stored_bootdelay)：主要用于判断是否有按键按下。如果按下，则不执行bootcmd命令，进入cli_loop 命令行模式；如果不按下，则执行bootcmd命令，跳转到加载Linux启动。  2.6.3 cli_loop #  void cli_loop(void) { bootstage_mark(BOOTSTAGE_ID_ENTER_CLI_LOOP); #ifdef CONFIG_HUSH_PARSER  parse_file_outer(); /* This point is never reached */ for (;;);\t//死循环 #elif defined(CONFIG_CMDLINE)  cli_simple_loop(); #else  printf(\u0026#34;## U-Boot command line is disabled. Please enable CONFIG_CMDLINE\\n\u0026#34;); #endif /*CONFIG_HUSH_PARSER*/} 如上代码，程序只执行parse_file_outer来处理用户的输入、输出信息。\n 好啦，基本到这里，我们已经对Uboot的启动流程了然于胸了吧！\n当然，更深层次的不建议去深入了解，有时间可以慢慢去研究。\n 大家有疑问，可以评论区交流\u0026hellip;\u0026hellip;\n参考文章：\n[1]：boadr_init_f介绍\n[2]：启动流程参考\n[3]：main_loop相关\n"},{"id":7,"href":"/docs/embeded_tech/embeded_interview/","title":"嵌入式面经","section":"嵌入式","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":8,"href":"/docs/embeded_tech/self_improve/10w+%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/","title":"【10W+阅读】耗时一周总结的嵌入式学习路线，超详细","section":"嵌入式工程师养成记","content":"人们常说：“人生就是一场场游戏，我们要做的，就是打怪，升级，通关”，学习嵌入式的过程也是如此。\n1、前言 #  最近看到知乎上，给我推送了很多类似的回答，借此机会，也想着重新审视一下自己的学习历程，以及结合自身和大牛，分享一些学习经验，希望对大家有所启发和帮助。\n本文主要目的是为了：\n 提供一张嵌入式学习路线地图 提供不同阶段的学习建议 推荐不同阶段的学习资料  3000余字，耗时1周，建议收藏；码字不易，如有帮助，慷慨三连\n 本文将嵌入式学习路线分为几个方面：\n 嵌入式基础必备知识 51单片机 STM32单片机 小而美的RTOS ARM+LINUX   在这个快节奏的时代，能静下心，耐住性子看看文章，实属不易。\n  2、嵌入式基础必备知识 #  老子曰：“合抱之木，生于毫末：九层之台，起于垒土；千里之行，始于足下”，根基的重要性不言而喻。\n那么对于嵌入式这条路线而言，如何建立一个稳固的根基？\n 2.1、学习内容 #   C语言基础  该部分，主要包括几个核心知识点：三大语法结构、常用的数据类型、函数、结构体、指针、文件操作等。\n 硬件基础知识  该部分，核心知识点在于：电路基础知识、数电模电基础知识、常用的电子元器件等。\n 数据结构  核心知识点：数组、队列、链表、堆栈、树、图、散列表等。\n 操作系统  核心知识点：进程管理、内存管理、文件管理、输入输出管理等。\n 计算机原理  核心知识点：数据表示和运算、存储系统、指令系统、总线系统、中央处理器、输入输出系统等。\n 2.2、学习建议 #   对于C语言基础学习，一定要重点熟练掌握，根基的牢固直接决定了我们的代码质量。 对于硬件基础学习，要适当了解，要能够看懂一些简单的电路结构，认识常用的电子元器件。 对于数据结构学习，前五个是必备学习的，可能在刚开始学习的时候，可能会感觉不到作用在哪里，但是随着接触到嵌入式底层设计以及算法设计的时候，才会恍然大悟。 对于操作系统学习，重点学习其思想，对相关知识点有一个大概的了解，后续接触到继续重点学习，这些无论是RTOS，还是Linux，都有涉及到的。 对于计算机原理学习，可以将其看作是嵌入式系统的各个模块的详解，会让你对嵌入式有一个整体的了解，每一个部分都值得深究。   2.3、学习资料 #   C语言基础：推荐经典书籍**《C语言程序设计》（第2版）谭浩强版本**。 硬件基础：大学里面的《数电模电》书籍所涉及的知识即可。 数据结构：推荐经典书籍**《数据结构》——严蔚敏版**。 操作系统、计算机原理：我用的是**《王道》的系列丛书**，个人感觉不错。  计算机组成、数据结构、操作系统、数据库是嵌入式或者说计算机的入门必读书籍，并且也被列入高校教材内，是真正的基础知识。\n 以上，不一定是全部看完才能体验编程的乐趣，这个基础是一个循序渐进的过程，也不是一朝一夕就能完成的，可以先有一个大概，后续做项目时，哪里不懂补哪里！这里涉及到一个重要的学习方法：项目导向的学习法。 3、嵌入式入门篇——51单片机 #  在上面的基础知识进行熟悉之后（C语言基础、计算机组成、硬件基础必备），我们准备叩开嵌入式世界的大门。\n入门篇，依旧推荐51单片机，当然有人会说，直接上STM32岂不更好？\n我的看法：建议新手还是以51单片机来入门，因为STM32体系架构比51大很多，对于新手刚开始可能会不太容易适应。\n 3.1、学习内容 #  该部分，主要在最小嵌入式系统中，实现各种有趣的实验。通过51单片机的学习，我们要做到：\n 软件类：  主要知识点有：认识单片机、熟悉逻辑运算、点亮一颗LED灯、按键检测、串口通信、定时器、中断等。\n 硬件类：  主要知识点有：电阻元器件了解，基本模块电路了解，时钟电路，尝试绘制51单片机原理图和PCB\n 3.2、学习建议 #   对于软件类，我们主要做到：认识单片机，熟悉单片机的GPIO的输入、输出操作，串口通信协议掌握等，这些部分都是任何一款嵌入式设备的必备技能。 对于硬件类：我们主要做到：能看懂电路图，熟悉一些简单模块的设计电路，了解Altium Designer的使用方法。   3.3、学习资料 #  51单片机：郭天祥的51单片机教程，经典著作，经久不衰，强烈推荐。\n 庄子说：“水之积也不厚，则其负大舟也无力。“\n该部分，是嵌入式领域的基石，只有将基础打牢，才能负得起Linux泰坦号。 4、STM32进阶篇 #  STM32是C51的进阶版，拥有C51的基础知识，开发STM32会得心应手。\nSTM32的系统架构以及硬件设计相比于C51来说，都是上升了一个维度的，这也是为什么我推荐入门学习C51的原因。\n 以STM32F407平台为基础，去学习目前嵌入式主流的一些技术，探寻底层的原理，做到不同平台，都能够得心应手。\n 4.1、学习内容 #   基础练习  该部分，主要练习：点亮LED灯、GPIO的输入输出操作、中断操作、UART通信、IIC通信等\n 进阶练习  该部分，主要练习：DMA通信、SPI通信、CAN通信、LCD显示屏，ADC等\n 高阶练习  该部分，主要学习：STM32时钟架构、总线架构、电源管理、代码框架、SDIO通信、USB通信等。\n 4.2、学习建议 #   对于基础练习，主要目的是为了方便让我们从C51到STM32环境的过渡。 对于进阶练习，主要练习一些通信类相关的协议，可以结合一些传感器进行开发。 对于高阶练习，主要目的是为了熟悉单片机的设计架构，编程的框架，以及一些更复杂的通信技术。  另外，STM32会有寄存器和库函数两个版本，建议交叉学习，理解会更加深刻。 4.3、学习资料 #  STM32单片机：推荐正点原子、野火的STM32F103或者STM32F407系列。\n两家的学习资料都非常丰富，既有详细的文档说明，也有完整的学习视频教程，非常适合新手入门学习。\n 俗话说：“有道无术，术尚可求，有术无道，止于术”。要明白道和术的区别，不要本末倒置。 5、小而美的RTOS #  RTOS，实时操作系统，可以理解为STM32与Linux之间的桥梁，由于其实现思想大都取之于Linux，所以也称之为精简版的Linux。\n我们常用的有实时操作系统有：UCOS，VxWork，FreeRtos，近些年RT-Thread也异军突起。\n学习这些简单的嵌入式系统，一来能够帮助我们为学习Linux操作系统打下基础，二来也能够扩宽我们的职业道路。\n前面也说过了，无论是UCOS、FreeRtos、Rt-thread，其内部的设计思想大同小异，下面主要以Ucos为例。\n5.1、学习内容 #   实时系统学习  该部分，主要学习：移植Ucos系统、多任务管理、调度算法、消息队列、信号量互斥量、事件、内存管理等。\n 5.2、学习建议 #   对于实时系统学习，除了上述的那些核心知识点外，还要结合2.1 基础必备知识的操作系统书籍加深理解。   5.3、学习资料 #  RTOS的学习：依旧推荐正点原子，野火，因为这些实时操作系统开发，可以基于STM32开发板，同时也有非常详细的文档和视频教学。\n 6、ARM+Linux篇 #  学习完RTOS后，基本嵌入式所涉及的技术已经掌握一半了，你也可以独立完成一些小的项目，也可以找到一个不错的工作，但是一定不要自我满足，有机会一定要接触Linux。\n还是那句话：ARM+Linux，也是最为复杂的东西，如果你不去接触Linux，你永远不知道嵌入式的魅力。 Linux开发又分为驱动开发，内核开发，应用开发，每一个方向都需要几年甚至几十年的积累。\n 作为初学者，我们要做的就是宏观了解，扩大我们的知识面，然后去选择自己感兴趣的方面。\n 6.1、学习内容 #   Linux基础篇  该部分主要学习：Linux常用命令、VIM学习、Linux的Shell编程、Gcc编译、Makefile等。\n 驱动篇  该部分主要学习：内核模块编译原理、字符设备驱动框架、平台设备驱动、设备树、Pinctrl子系统、I2C子系统、中断子系统、块设备驱动框架、Bootloader等\n 内核篇  该部分主要学习：系统调用、存储管理、进程管理、内存管理、文件管理等。\n 应用篇  该部分主要学习：QT编程、TCP/IP协议、HTTP协议等。\n 6.2、学习建议 #   对于基础学习，刚接触到Linux，一般比较难上手，与之前的单片机完全不同，需要一个熟悉环境的过程。 对于驱动学习，重要在于明白“如何在Linux环境下编写驱动程序”，驱动的底层原理还是那样，加了一层层的框架，需要我们去熟悉。 对于内核学习，上述也是系统的几大核心特色，重点在于\u0026quot;如何使Linux性能最优\u0026quot; 对于应用学习，上述的几个方面也是基础，重点还在于开发什么应用，去学习哪方面的知识，没有定论。  对于Linux，有句老话“学习Linux，3年才算入门，5年才勉强算Linux工程师，对于不太熟悉的领域，博主也不敢妄加断言。” 6.3、学习资料 #   对于基础学习，推荐**《鸟哥的Linux私房菜》，《Unix环境高级编程》**等入门书籍。 对于驱动开发，推荐**《Linux设备驱动开发详解》**，Linux内核源码详解等。 对于内核学习，推荐**《Linux Shell脚本攻略》、《深入理解Linux内核》**等。 对于应用开发，推荐**《嵌入式Linux应用开发完全手册》、《Unix网络编程》**等。 另外，推荐正点原子，野火，韦东山三个Linux开发教程，韦老师的课程好评居多，但还是看哪个更适合自己。   7、总结 #  全文整体的学习路线：嵌入式基础学习 -\u0026gt; 51单片机 -\u0026gt; STM32单片机 -\u0026gt; RTOS篇 -\u0026gt; ARM+Linux每一个部分，也都从学习内容，学习建议，学习资料三个方面来展开，层层深入，步步指引。\n文章既是我的学习历程，又结合了一些大佬的学习分享，不断调整总结出来的，如有异同，可以讨论。\n全文3000余字，耗时1周，如有帮助，望不吝点赞关注。\n最后，文章所涉及的学习资料以及整理的思维导图，全部会在我的星球【嵌入式艺术】分享！\n"}]