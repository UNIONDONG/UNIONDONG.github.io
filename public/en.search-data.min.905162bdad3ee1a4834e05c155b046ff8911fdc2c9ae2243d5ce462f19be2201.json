[{"id":0,"href":"/docs/linux/linux_api/","title":"Linux API 揭秘","section":"Linux开发","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":1,"href":"/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/","title":"【Linux API 揭秘】module_init与module_exit","section":"Linux API 揭秘","content":" Linux Version：6.6\nAuthor：Donge\nGithub：linux-api-insides\n  1、函数作用 #  module_init和module_exit是驱动中最常用的两个接口，主要用来注册、注销设备驱动程序。\n并且这两个接口的实现机制是一样的，我们先以module_init为切入点分析。\n 2、module_init函数解析 #  2.1 module_init #  #ifndef MODULE /** * module_init() - driver initialization entry point * @x: function to be run at kernel boot time or module insertion * * module_init() will either be called during do_initcalls() (if * builtin) or at module insertion time (if a module). There can only * be one per module. */ #define module_init(x)\t__initcall(x);  ...... #else /* MODULE */ ...... /* Each module must use one module_init(). */ #define module_init(initfn)\t\\ static inline initcall_t __maybe_unused __inittest(void)\t\\ { return initfn; }\t\\ int init_module(void) __copy(initfn)\t\\ __attribute__((alias(#initfn)));\t\\ ___ADDRESSABLE(init_module, __initdata);  ...... #endif 函数名称：module_init\n文件位置：include/linux/module.h\n函数解析：\n 在Linux内核中，驱动程序可以以两种方式存在：内建(Builtin)和模块(Module)。内建驱动就是在编译时，直接编译进内核镜像中；而模块驱动则是在内核运行过程中动态加载卸载的。\n module_init函数的定义位置有两处，使用MODULE宏作为判断依据。MODULE是一个预处理器宏，仅当该驱动作为模块驱动时，编译的时候会加入MODULE的定义。\n 这里难免会有疑问：为什么会有两套实现呢？\n 其实，当模块被编译进内核时，代码是存放在内存的.init字段，该字段在内核代码初始化后，就会被释放掉了，所以当可动态加载模块需要加载时，就需要重新定义了。\n 2.1.1 模块方式 #  当驱动作为可加载模块时，MODULE宏被定义，我们简单分析一下相关代码\n#define module_init(initfn)\t\\ static inline initcall_t __maybe_unused __inittest(void)\t\\ { return initfn; }\t\\ int init_module(void) __copy(initfn)\t\\ __attribute__((alias(#initfn)));\t\\ ___ADDRESSABLE(init_module, __initdata);  static inline initcall_t __maybe_unused __inittest(void) { return initfn; }：一个内联函数，返回传入的initfn函数。  __maybe_unused ：编译器指令，用于告诉编译器，该函数可能不会使用，以避免编译器产生警告信息。   int init_module(void) __copy(initfn) __attribute__((alias(#initfn)));：init_module函数的声明  __copy(initfn)：编译器指令，也就是将我们的initfn函数代码复制到init_module中， __attribute__((alias(#initfn)))：编译器指令，将init_module函数符号的别名设置为initfn。   ___ADDRESSABLE(init_module, __initdata);：一个宏定义，主要用于将init_module函数的地址放入__initdata段，这样，当模块被加载时，init_module函数的地址就可以被找到并调用。  总的来说，如果是可加载的ko模块，module_init宏主要定义了init_module函数，并且将该函数与initfn函数关联起来，使得当模块被加载时，初始化函数可以被正确地调用。\n 2.1.2 内建方式 #  当模块编译进内核时，MODULE宏未被定义，所以走下面流程\n#define module_init(x)\t__initcall(x);  2.2 __initcall #  #define __initcall(fn) device_initcall(fn)  #define device_initcall(fn)\t__define_initcall(fn, 6)  #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)  #define ___define_initcall(fn, id, __sec)\t\\ __unique_initcall(fn, id, __sec, __initcall_id(fn))  #define __unique_initcall(fn, id, __sec, __iid)\t\\ ____define_initcall(fn,\t\\ __initcall_stub(fn, __iid, id),\t\\ __initcall_name(initcall, __iid, id),\t\\ __initcall_section(__sec, __iid))  #define ____define_initcall(fn, __unused, __name, __sec)\t\\ static initcall_t __name __used \\ __attribute__((__section__(__sec))) = fn;  #define __initcall_stub(fn, __iid, id)\tfn  /* Format: \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt; */ #define __initcall_id(fn)\t\\ __PASTE(__KBUILD_MODNAME,\t\\ __PASTE(__,\t\\ __PASTE(__COUNTER__,\t\\ __PASTE(_,\t\\ __PASTE(__LINE__,\t\\ __PASTE(_, fn))))))  /* Format: __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt; */ #define __initcall_name(prefix, __iid, id)\t\\ __PASTE(__,\t\\ __PASTE(prefix,\t\\ __PASTE(__,\t\\ __PASTE(__iid, id))))  #define __initcall_section(__sec, __iid)\t\\ #__sec \u0026#34;.init\u0026#34;  /* Indirect macros required for expanded argument pasting, eg. __LINE__. */ #define ___PASTE(a,b) a##b #define __PASTE(a,b) ___PASTE(a,b) 函数名称：__initcall\n文件位置：include/linux/init.h\n函数解析：设备驱动初始化函数\n 2.2.1 代码调用流程 #  module_init(fn) |--\u0026gt; __initcall(fn) |--\u0026gt; device_initcall(fn) |--\u0026gt; __define_initcall(fn, 6) |--\u0026gt; ___define_initcall(fn, id, __sec) |--\u0026gt; __initcall_id(fn) |--\u0026gt; __unique_initcall(fn, id, __sec, __iid) |--\u0026gt; ____define_initcall(fn, __unused, __name, __sec) |--\u0026gt; __initcall_stub(fn, __iid, id) |--\u0026gt; __initcall_name(prefix, __iid, id) |--\u0026gt; __initcall_section(__sec, __iid) |--\u0026gt; ____define_initcall(fn, __unused, __name, __sec)   进行函数分析前，我们先要明白#和##的概念\n 2.2.2 #和##的作用 #     符号 作用 举例     ## ##符号 可以是连接的意思 例如 __initcall_##fn##id 为__initcall_fnid那么，fn = test_init，id = 6时，__initcall##fn##id 为 __initcall_test_init6   # #符号 可以是字符串化的意思 例如 #id 为 \u0026quot;id\u0026quot;，id=6 时，#id 为\u0026quot;6\u0026quot;      更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2.2.3 函数解析 #   下面分析理解比较有难度的函数\n #define device_initcall(fn)\t__define_initcall(fn, 6) #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)  .initcall##id：通过##来拼接两个字符串：.initcall6  #define ___define_initcall(fn, id, __sec)\t\\ __unique_initcall(fn, id, __sec, __initcall_id(fn))  /* Format: \u0026lt;modname\u0026gt;__\u0026lt;counter\u0026gt;_\u0026lt;line\u0026gt;_\u0026lt;fn\u0026gt; */ #define __initcall_id(fn)\t\\ __PASTE(__KBUILD_MODNAME,\t\\ __PASTE(__,\t\\ __PASTE(__COUNTER__,\t\\ __PASTE(_,\t\\ __PASTE(__LINE__,\t\\ __PASTE(_, fn))))))  /* Indirect macros required for expanded argument pasting, eg. __LINE__. */ #define ___PASTE(a,b) a##b #define __PASTE(a,b) ___PASTE(a,b)  ___PASTE：拼接两个字符串 __initcall_id：它用于生成一个唯一的标识符，这个标识符用于标记初始化函数。  __KBUILD_MODNAME：当前正在编译的模块的名称 __COUNTER__：一个每次使用都会递增计数器，用于确保生成名称的唯一性 __LINE__：当前代码的行号     #define __unique_initcall(fn, id, __sec, __iid)\t\\ ____define_initcall(fn,\t\\ __initcall_stub(fn, __iid, id),\t\\ __initcall_name(initcall, __iid, id),\t\\ __initcall_section(__sec, __iid))  #define ____define_initcall(fn, __unused, __name, __sec)\t\\ static initcall_t __name __used \\ __attribute__((__section__(__sec))) = fn;  #define __initcall_stub(fn, __iid, id)\tfn  /* Format: __\u0026lt;prefix\u0026gt;__\u0026lt;iid\u0026gt;\u0026lt;id\u0026gt; */ #define __initcall_name(prefix, __iid, id)\t\\ __PASTE(__,\t\\ __PASTE(prefix,\t\\ __PASTE(__,\t\\ __PASTE(__iid, id))))  #define __initcall_section(__sec, __iid)\t\\ #__sec \u0026#34;.init\u0026#34; __unique_initcall：调用____define_initcall，关键实现部分\n____define_initcall：定义一个名为 __name 的 initcall_t 类型的静态变量，并将其初始化为 fn，并放入特定的__sec段中。\n __initcall_stub：表示唯一的函数名fn __initcall_name：表示一个唯一的变量名 __initcall_section： 生成一个唯一的段名。 #__sec \u0026quot;.init\u0026quot;：将两个字符串拼接起来，比如：__sec=.initcall6，拼接后的段为：.initcall6.init，该段为最终存储的段。   字段通过链接器链接起来，形成一个列表进行统一管理。\n 这些字段我们可以在arch/arm/kernel/vmlinux.lds中查看。\n ...... __initcall6_start = .; KEEP(*(.initcall6.init)) KEEP(*(.initcall6s.init)) ......  3、module_exit函数解析 #   module_exit和module_init的实现机制几乎没有差别，下面就简单介绍一下。\n 3.1 module_exit #  #ifndef MODULE  /** * module_exit() - driver exit entry point * @x: function to be run when driver is removed * * module_exit() will wrap the driver clean-up code * with cleanup_module() when used with rmmod when * the driver is a module. If the driver is statically * compiled into the kernel, module_exit() has no effect. * There can only be one per module. */ #define module_exit(x)\t__exitcall(x);  ...... #else /* MODULE */ ...... /* This is only required if you want to be unloadable. */ #define module_exit(exitfn)\t\\ static inline exitcall_t __maybe_unused __exittest(void)\t\\ { return exitfn; }\t\\ void cleanup_module(void) __copy(exitfn)\t\\ __attribute__((alias(#exitfn)));\t\\ ___ADDRESSABLE(cleanup_module, __exitdata);  ...... #endif 函数名称：module_exit\n文件位置：include/linux/module.h\n3.1.1 模块方式 #  作为模块方式，与module_init的实现方式一样，定义cleanup_module与exitfn函数相关联，存放在__exitdata段内。\n 3.1.2 内建方式 #  当模块编译进内核时，MODULE宏未被定义，所以走下面流程\n#define module_exit(x)\t__exitcall(x);  3.2 __exitcall #  #define __exitcall(fn)\t\\ static exitcall_t __exitcall_##fn __exit_call = fn  #define __exit_call\t__used __section(\u0026#34;.exitcall.exit\u0026#34;) 函数名称：__initcall\n文件位置：include/linux/init.h\n函数解析：设备驱动卸载函数\n__exitcall_##fn：定义一个新的 exitcall_t 类型的静态变量，并赋值为fn\n__exit_call：__used __section(\u0026quot;.exitcall.exit\u0026quot;)，定义该函数存储的段\n 4、扩展 #   还记得__define_initcall的定义吗？\n #define pure_initcall(fn) __define_initcall(fn, 0)  #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s)  #define __initcall(fn) device_initcall(fn) 不同的宏定义，被赋予了不同的调用等级，最后将不同的驱动初始化函数统一汇总到__initcallx_start字段统一管理，形成一个有序的列表。\n这样，我们在内核中，按照顺序遍历这个列表，最后执行对应的模块初始化函数fn即可实现驱动的初始化。\n 欢迎关注【嵌入式艺术】，董哥原创！  "},{"id":2,"href":"/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/","title":"一、uboot基础了解","section":"Uboot开发","content":"一、uboot基础了解 #  1. U-boot是什么 #  U-Boot，全称 Universal Boot Loader，是遵循GPL条款的从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的 开放源码项目。\nU-boot，是一个主要用于嵌入式系统的引导加载程序，可以支持多种不同的计算机系统结构，其主要作用为：==引导系统的启动！==目前，U-Boot不仅支持Linux系统的引导，还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android等多种嵌入式操作系统。\n2. U-boot主要特性及功能 #   开放：开放的源代码 多平台：支持多种嵌入式操作系统，如Linux、NetBSD、android等 生态：有丰富的设备驱动源码，如以太网、SDRAM、LCD等，同时也具有丰富的开发文档。  3. U-boot下载地址 #  Uboot开发源码：\n  https://source.denx.de/u-boot/u-boot\n  https://ftp.denx.de/pub/u-boot/\n  其他厂商定制的uboot源码：\n 野火  4. U-boot目录结构 #     目录 含义     arch 各个厂商的硬件信息，目录下包括支持的处理器类型   arch/arm/cpu/xxx **每一个子文件夹，包含一种cpu系列。**每个子文件夹下包含cpu.c（CPU初始化），interrupts.c（设置中断和异常），start.S（U-boot的启动文件，早期的初始化）。   board 与开发板有关，每一个子文件夹代表一个芯片厂家，芯片厂家下，每一个子文件夹，表示一个开发板   common 存放与处理器体系无关的通用代码，可以说为通用核心代码！   cmd 存放uboot的相关命令实现部分   drivers 存放外围芯片驱动，网卡，USB等   disk 存放驱动磁盘的分区处理代码   fs 本目录下存放文件系统相关代码，每一个子文件夹表示文件系统   net 网络协议相关代码   doc uboot说明文档   include 各种头文件   post 上电自检代码   api 外部扩展程序的API和示例   tools 编译S-Record或者U-boot镜像的相关工具    5. 如何编译Uboot #  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean make ARCH=arm CORSS_COMPILE=arm-linux-gnueabihf- colibri-imx6ull_defconfig make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 ARCH=arm：arm架构\nCROSS_COMPILE：使用的交叉编译器\n 如果编译出错，your compile older 6.0，可以参考【1】\n colibri-imx6ull_defconfig：指定一个config文件，作为相关版型的配置信息\nV=1：这个选项能显示出编译过程中的详细信息，即是verbose编译模式\n-j8：多核并行编译，可以提高编译速度，受硬件限制\n6. U-boot工作模式 #   U-boot的工作模式有：启动加载模式和下载模式\n  启动加载模式：  启动加载模式，为Bootloader正常工作模式，一款开发板，正常上电后，Bootloader将嵌入式操作系统==从FLASH中加载到SDRAM中==运行。\n 下载模式：  下载模式，就是Bootloader通过通信，将内核镜像、根文件系统镜像从PC机直接下载到目标板的FLASH中。\n7. U-boot的存放位置 #  嵌入式系统，一般使用Flash来作为启动设备，Flash上存储着U-boot、环境变量、内核映像、文件系统等。U-boot存放于Flash的起始地址，所在扇区由Soc规定。\n8. U-boot系列文章汇总 #   下面是进行U-boot开发期间，感觉比较不错的资料，总结分享一下！\n [1] : Uboot官网、Uboot官方指南、官方指南2\n[2] : https://blog.51cto.com/u_9291927/category5\n[3] : https://blog.csdn.net/ooonebook/category_6484145.html\n[4]：https://blog.csdn.net/qq_36310253/category_9332618.html\n 欢迎关注【嵌入式艺术】，董哥原创！  "},{"id":3,"href":"/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/","title":"Soc的Bring Up流程","section":"嵌入式面经","content":"1、Bring Up流程 #  SOC (System on a Chip) bring-up是一个复杂的过程，涉及到硬件、固件和软件的集成和验证，以下是一个基于BROM，SPL，UBOOT和Linux的启动流程的概述：\n BROM (Boot Read-Only Memory)启动：启动的最初阶段，在这个阶段，系统会执行芯片ROM里面的代码，这部分代码主要用来检查启动模式，包括NOR、Nand、Emmc等，然后从对应的存储介质中加载SPL(Secondary Program Loader)代码。 SPL (Secondary Program Loader)启动：SPL属于Uboot的一部分，它的主要作用就是：初始化硬件并加载完整的U-boot，主要体现在初始化时钟、看门狗、DDR、GPIO以及存储外设，最后将U-boot代码加载到DDR中执行。 U-Boot启动：U-boot的主要作用是：引导加载Kernel和DTS。U-boot在启动之后，同样初始化Soc硬件资源，然后会计时等待，并执行默认的启动命令，将Kernel和DTS信息从存储介质中读取出来并加载到内存中执行。 Kernel启动：在U-Boot加载了内核映像和设备树之后，系统会启动Linux。在这个阶段，系统会初始化各种硬件设备，加载驱动程序并启动用户空间应用程序。   更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2、常见问题 #  Q：为什么上一个阶段已经初始化了硬件资源，下一个阶段为何重复初始化？\nA：\n  每个阶段的硬件初始化，其目标和需求都不同，硬件配置也会不一样，因此在不同阶段进行不同的初始化。\n  硬件状态可能会改变，在SOC启动过程中，硬件状态可能会因为电源管理、时钟管理等原因而改变，这可能需要在每个阶段都重新初始化以确保其正确工作\n  为了保证硬件资源的可靠性，最好每个阶段都重新初始化一次\n   Q：U-boot加载内核时，会进行重定位的操作，这一操作有何意义？\nA：\n U-boot的重定位，主要作用是为了 给内核提供一个连续的、大的内存空间，供内核和其他应用程序使用 U-boot的加载过程分两个阶段，即：SPL和U-boot，   在SPL阶段，主要将U-boot代码从Flash中加载到RAM指定位置 在U-boot阶段，U-boot会将自身从RAM的开始部分移动到RAM的末尾，占用高地址空间，从而让低地址空间可以作为一个连续的，大的内存空间供内核和其他应用程序使用。   Q：在Bring Up中，为了保证启动时间，如何裁剪？\nA：\n 启动时间的裁剪是一个重要的步骤，其主要目标是缩短从电源打开到操作系统完全启动的时间。\n  优化Bootloader：减小Bootloader的代码大小，减少硬件初始化（只初始化必要硬件设备）等 优化Kernel：减少启动服务数量，优化服务的启动顺序，使用预加载技术等方法来实现。 使用快速启动模式：一些SOC支持快速启动模式，这种模式下，SOC会跳过一些不必要的硬件初始化和自检过程，从而更快地启动。 使用休眠和唤醒技术：一些SOC还支持休眠和唤醒技术，这种技术可以将系统的状态保存到非易失性存储器中，然后关闭系统。当系统再次启动时，可以直接从非易失性存储器中恢复系统的状态，从而更快地启动。   "},{"id":4,"href":"/docs/embeded_tech/self_improve/","title":"嵌入式工程师养成记","section":"嵌入式","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":5,"href":"/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","title":"【Linux API 揭秘】container_of函数详解","section":"Linux API 揭秘","content":" Linux Version：6.6\nAuthor：Donge\nGithub：linux-api-insides\n  1、container_of函数介绍 #  container_of可以说是内核中使用最为频繁的一个函数了，简单来说，它的主要作用就是根据我们结构体中的已知的成员变量的地址，来寻求该结构体的首地址，直接看图，更容易理解。\n 下面我们看看linux是如何实现的吧\n 2、container_of函数实现 #  /** * container_of - cast a member of a structure out to the containing structure * @ptr:\tthe pointer to the member. * @type:\tthe type of the container struct this is embedded in. * @member:\tthe name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */ #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ static_assert(__same_type(*(ptr), ((type *)0)-\u0026gt;member) ||\t\\ __same_type(*(ptr), void),\t\\ \u0026#34;pointer type mismatch in container_of()\u0026#34;);\t\\ ((type *)(__mptr - offsetof(type, member))); })  函数名称：container_of\n文件位置：include/linux/container_of.h\n该函数里面包括了一些封装好的宏定义以及函数，比如：static_assert、__same_type、offsetof，以及一些指针的特殊用法，比如：(type *)0)，下面我们一一拆解来看。\n2.1 static_assert #  /** * static_assert - check integer constant expression at build time * * static_assert() is a wrapper for the C11 _Static_assert, with a * little macro magic to make the message optional (defaulting to the * stringification of the tested expression). * * Contrary to BUILD_BUG_ON(), static_assert() can be used at global * scope, but requires the expression to be an integer constant * expression (i.e., it is not enough that __builtin_constant_p() is * true for expr). * * Also note that BUILD_BUG_ON() fails the build if the condition is * true, while static_assert() fails the build if the expression is * false. */ #define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr) #define __static_assert(expr, msg, ...) _Static_assert(expr, msg) 函数名称：static_assert\n文件位置：include/linux/build_bug.h\n函数解析：该宏定义主要用来 在编译时检查常量表达式，如果表达式为假，编译将失败，并打印传入的报错信息\n expr：该参数表示传入进来的常量表达式 ...：表示编译失败后，要打印的错误信息 _Static_assert：C11中引入的关键字，用于判断表达式expr并打印错误信息msg。  在container_of函数中，主要用来断言判断\nstatic_assert( __same_type(*(ptr), ((type *)0)-\u0026gt;member) || __same_type(*(ptr), void) , \u0026#34;pointer type mismatch in container_of()\u0026#34; );  2.2 __same_type #  /* Are two types/vars the same type (ignoring qualifiers)? */ #ifndef __same_type # define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b)) #endif 函数名称：__same_type\n文件位置：include/linux/compiler.h\n函数解析：该宏定义用于检查两个变量是否是同种类型\n __builtin_types_compatible_p：gcc的内建函数，判断两个参数的类型是否一致，如果是则返回1 typeof：gcc的关键字，用于获取变量的类型信息  了解完__same_type，想要理解__same_type(*(ptr), ((type *)0)-\u0026gt;member)，需要先弄明白(type *)0的含义。\n  更多干货可见：高级工程师聚集地，助力大家更上一层楼！\n  2.3 (type *)0 #  (type *)0，该如何理解这个表达式呢？\n 首先，type是我们传入进来的结构体类型，比如上面讲到的struct test，而这里所做的可以理解为强制类型转换：(struct test *)addr。 addr可以表示内存空间的任意的地址，我们在强制转换后，默认后面一片的内存空间存储的是该数据结构。   而(type *)0的作用，也就是默认将0地址处的内存空间，转换为该数据类型。   我们就把0，当作我们正常的addr地址变量来操作，((type *)0)-\u0026gt;member，就是获取我们结构体的成员对象。 ((type *)0)-\u0026gt;member：是一种常见的技巧，用于直接获取结构体type的成员member的类型，而不需要定义一个type类型的对象。   2.4 offsetof #  #ifndef offsetof #define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #endif 函数名称：offsetof\n文件位置：include/linux/stddef.h\n函数解析：该宏定义用于获取结构体中指定的成员，距离该结构体偏移量。\n TYPE：表示结构体的类型 MEMBER：表示指定的结构体成员 __builtin_offsetof：gcc内置函数，直接返回偏移量。   在新的linux源码中，直接引用了gcc内置的函数，而在老的内核源码中，该偏移量的实现方式如下：\n#define offsetof(TYPE, MEMBER) ((size_t) \u0026amp;((TYPE *)0)-\u0026gt;MEMBER) 同样用到了((TYPE *)addr)，上面我们知道\n ((TYPE *)addr)-\u0026gt;MEMBER：表示获取该结构体的成员 \u0026amp;((TYPE *)addr)-\u0026gt;MEMBER)：加了一个\u0026amp;，表示地址，取该成员的内存地址。  比如我们addr=0x00000010，那么\u0026amp;((TYPE *)0x00000010)-\u0026gt;MEMBER)就相当于0x00000010+size 比如我们addr=0，那么\u0026amp;((TYPE *)0)-\u0026gt;MEMBER)就相当于size     到这里，我们对container_of函数内部涉及的相关知识了然于胸，下面我们再来看container_of，简直容易到起飞。\n 2.5 container_of #  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ static_assert(__same_type(*(ptr), ((type *)0)-\u0026gt;member) ||\t\\ __same_type(*(ptr), void),\t\\ \u0026#34;pointer type mismatch in container_of()\u0026#34;);\t\\ ((type *)(__mptr - offsetof(type, member))); })  static_assert：断言信息，避免我们传入的参数类型不对，而做的编译检查处理，直接忽略。  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ ((type *)(__mptr - offsetof(type, member))); })   offsetof(type, member)：计算的是结构体中的成员的偏移量，这里称为size\n  (__mptr - offsetof(type, member))：也就是根据我们已知的成员变量地址，计算出来结构体的首地址\n  ((type *)(__mptr - offsetof(type, member)))：最后强制转换为(type *)，结构体指针。\n   比如，我们已知的结构体成员的地址为0xffff0000，计算之后如下：\n 3、总结 #  linux内核中，小小的一个函数，内部包括的技巧如此之多：static_assert、__same_type、(type *)0、offsetof。\n了解完内部完整的实现手法之后，我们也可以手码一个container_of了 :)\n  欢迎关注【嵌入式艺术】，董哥原创！  "},{"id":6,"href":"/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","title":"二、uboot启动流程分析","section":"Uboot开发","content":"二、uboot启动流程分析 #   上一篇文章：（一）uboot基础了解 下一篇文章：（三）Uboot驱动模型\n 同大多数的Bootloader一样，uboot的启动过程也分为BL1、BL2两个阶段，分别对应着SPL和Uboot。\nSPL（BL1阶段）：负责开发板的基础配置和设备初始化，并且搬运Uboot到内存中，由汇编代码和少量的C语言实现\nUboot（BL2阶段）：主要负责初始化外部设备，引导Kernel启动，由纯C语言实现。\n 我们这篇文章，主要介绍Uboot（BL2阶段）的启动流程，BL1阶段启动流程的详细分析，可以见我的后续文章。想要深入了解的，可以好好研究下！\n 2.1、程序执行流程图 #  我们先总体来看一下Uboot的执行步骤，这里以EMMC作为启动介质，进行分析！\n无论是哪种启动介质，基本流程都相似，我们这就往下看！\n==打开图片，结合文档、图片、代码进行理解！==\n 2.2、u-boot.lds——Uboot的入口函数 #  u-boot.lds：是uboot工程的链接脚本文件，对于工程的编译和链接有非常重要的作用，决定了uboot的组装，并且u-boot.lds链接文件中的ENTRY(_start)指定了uboot程序的入口地址。\n 如果不知道u-boot.lds放到在哪里，可以通过find -name u-boot.lds查找，根目录要进入到uboot的源码的位置哦！\n如果查找结果有很多，结合自己的板子信息，确定自己使用的u-boot.lds。\n当然，准确的方法是查看Makefile文件，分析出来u-boot.lds所生成的位置。\n 在u-boot.lds的文件中，可以看到.text段，存放的就是执行的文本段。截取部分代码段如下：\nOUTPUT_FORMAT(\u0026#34;elf32-littlearm\u0026#34;, \u0026#34;elf32-littlearm\u0026#34;, \u0026#34;elf32-littlearm\u0026#34;) OUTPUT_ARCH(arm) ENTRY(_start) SECTIONS { . = 0x00000000;\t@起始地址  . = ALIGN(4);\t@四字节对齐  .text :\t{\t*(.__image_copy_start)\t@映像文件复制起始地址 *(.vectors)\t@异常向量表 arch/arm/cpu/armv7/start.o (.text*)\t@启动函数 } ...... }   ENTRY(_start)：程序的入口函数，_start在arch/arm/lib/vectors.S中定义.globl _start\n  SECTIONS定义了段，包括text文本段、data数据段、bss段等。\n  __image_copy_start在System.map和u-boot.map中均有定义\n  arch/arm/cpu/armv7/start.o对应文件arch/arm/cpu/armv7/start.S，该文件中定义了main函数的入口。\n   Tip：上面只进行大概分析，有汇编经验的朋友，可以详细进行分析！\n 2.3、board_init_f——板级前置初始化 #  跟随上文的程序执行流程图，我们看board_init_f这个函数。其位于common/board_f.c。\nvoid board_init_f(ulong boot_flags) { gd-\u0026gt;flags = boot_flags; gd-\u0026gt;have_console = 0; if (initcall_run_list(init_sequence_f)) hang(); } static const init_fnc_t init_sequence_f[] = { setup_mon_len, ... log_init, arch_cpu_init,\t/* basic arch cpu dependent setup */ env_init,\t/* initialize environment */ ... reloc_fdt, reloc_bootstage, reloc_bloblist, setup_reloc, ... } board_init_f()，其最核心的内容就是调用了init_sequence_f初始化序列，进行了一系列初始化的工作。\n主要包括：串口、定时器、设备树、DM驱动模型等，另外还包括global_data结构体相关对象的变量。\n 详细分析，可以看文末的参考文章[1]\n 我们需要注意的一点就是，在初始化队列末尾，执行了几个reloc_xxx的函数，这几个函数实现了Uboot的重定向功能。\n2.4、relocate_code重定向 #   重定向技术，可以说也算是Uboot的一个重点了，也就是将uboot自身镜像拷贝到ddr上的另外一个位置的动作。\n 2.4.1 为什么需要重定向呢？ #   一般需要重定向的条件如下：\n  uboot存储在只读存储器上，比如ROM、Nor flash，需要将代码拷贝到DDR上，才能完整运行Uboot。 为Kernel腾空间，Kernel一般会放在DDR的地段地址上，所以要把Uboot重定向到顶端地址，避免冲突。  2.4.2 Uboot是如何重定向的？ #  Uboot的重定向有如下几个步骤：\n 对relocate进行空间划分 计算uboot代码空间到relocate的位置的偏移 relocate旧的global_data到新的global_data空间上 relocate Uboot 修改relocate后的全局变量的label relocate中断向量表  运行大致流程：\narch/arm/lib/crt0.S文件内，主要实现了：\nENTRY(_main) bl board_init_f @@ 在board_init_f里面实现了 @@ （1）对relocate进行空间规划 @@ （2）计算uboot代码空间到relocation的位置的偏移 @@ （3）relocate旧的global_data到新的global_data的空间上 ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-\u0026gt;start_addr_sp */  bic sp, sp, #7 /* 8-byte alignment for ABI compliance */  ldr r9, [r9, #GD_BD] /* r9 = gd-\u0026gt;bd */  sub r9, r9, #GD_SIZE /* new GD is below bd */ @@ 把新的global_data地址放在r9寄存器中 adr lr, here ldr r0, [r9, #GD_RELOC_OFF] /* r0 = gd-\u0026gt;reloc_off */  add lr, lr, r0 @@ 计算返回地址在新的uboot空间中的地址。b调用函数返回之后，就跳到了新的uboot代码空间中。 ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u0026gt;relocaddr */ @@ 把uboot的新的地址空间放到r0寄存器中，作为relocate_code的参数 b relocate_code @@ 跳转到relocate_code中，在这里面实现了 @@ （1）relocate旧的uboot代码空间到新的空间上去 @@ （2）修改relocate之后全局变量的label @@ 注意，由于上述已经把lr寄存器重定义到uboot新的代码空间中了，所以返回之后，就已经跳到了新的代码空间了！！！！！！ bl relocate_vectors @@ relocate中断向量表  setup_reloc——重定向地址查看（仿真有关）  在这里我们说明一下board_init_f里面的setup_reloc初始化函数\nstatic int setup_reloc(void) { if (gd-\u0026gt;flags \u0026amp; GD_FLG_SKIP_RELOC) { debug(\u0026#34;Skipping relocation due to flag\\n\u0026#34;); return 0; } #ifdef CONFIG_SYS_TEXT_BASE #ifdef ARM  gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - (unsigned long)__image_copy_start; #elif defined(CONFIG_M68K)  /* * On all ColdFire arch cpu, monitor code starts always * just after the default vector table location, so at 0x400 */ gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - (CONFIG_SYS_TEXT_BASE + 0x400); #elif !defined(CONFIG_SANDBOX)  gd-\u0026gt;reloc_off = gd-\u0026gt;relocaddr - CONFIG_SYS_TEXT_BASE; #endif #endif  memcpy(gd-\u0026gt;new_gd, (char *)gd, sizeof(gd_t)); debug(\u0026#34;Relocation Offset is: %08lx\\n\u0026#34;, gd-\u0026gt;reloc_off); if (is_debug_open()) { printf(\u0026#34;Relocating to %08lx, new gd at %08lx, sp at %08lx\\n\u0026#34;, gd-\u0026gt;relocaddr, (ulong)map_to_sysmem(gd-\u0026gt;new_gd), gd-\u0026gt;start_addr_sp); } return 0; } 由于，Uboot进行了重定向，所以按照常规的地址仿真的话，我们可能访问到错误的内存空间，通过setup_reloc的Relocating to %08lx打印，我们可以得到重定向后的地址，方便我们仿真。\nUboot的重定向也有相当大的一部分知识点，上面也仅仅是简单介绍了relocate的基本步骤和流程，后续看大家需要，如果大家想了解，我再补上这一部分。\n2.4.3 Uboot重定向作用 #  总之，Uboot重定向之后，把Uboot整体搬运到了高端内存区，为Kernel的加载提供空间，避免内存践踏。\n2.5、board_init_r——板级后置初始化 #   我们接着跟着流程图往下看，重定向之后，Uboot运行于新的地址空间，接着我们执行board_init_r，主要作为Uboot运行的最后初始化步骤。\n board_init_r这个函数，同样位于common/board_f.c，主要用于初始化各类外设信息\nvoid board_init_r(gd_t *new_gd, ulong dest_addr) {\tif (initcall_run_list(init_sequence_r)) hang(); /* NOTREACHED - run_main_loop() does not return */ hang(); } static init_fnc_t init_sequence_r[] = { initr_reloc, initr_reloc_global_data, board_init,\t/* Setup chipselects */ initr_dm, initr_mmc, ... run_main_loop } 与board_init_f相同，同样有一个init_sequence_r初始化列表，包括：initr_dmDM模型初始化，initr_mmcMMC驱动初始化，等等。\n最终，uboot就运行到了run_main_loop，进而执行main_loop这个函数。\n2.6、main_loop——Uboot主循环 #   该函数为Uboot的最终执行函数，无论是加载kernel还是uboot的命令行体系，均由此实现。\n void main_loop(void) { const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, \u0026#34;main_loop\u0026#34;); if (IS_ENABLED(CONFIG_VERSION_VARIABLE)) env_set(\u0026#34;ver\u0026#34;, version_string); /* set version variable */ cli_init(); if (IS_ENABLED(CONFIG_USE_PREBOOT)) run_preboot_environment_command(); if (IS_ENABLED(CONFIG_UPDATE_TFTP)) update_tftp(0UL, NULL, NULL); s = bootdelay_process(); if (cli_process_fdt(\u0026amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(\u0026#34;No CLI available\u0026#34;); } env_set：设置环境变量，两个参数分别为name和value\ncli_init：用于初始化hash shell的一些变量\nrun_preboot_environment_command：执行预定义的环境变量的命令\nbootdelay_process：加载延时处理，一般用于Uboot启动后，有几秒的倒计时，用于进入命令行模式。\ncli_loop：命令行模式，主要作用于Uboot的命令行交互。\n2.6.1 bootdelay_process #   记得对照文章开始的执行流程图哦！\n 详细解释标注于代码中\u0026hellip;\u0026hellip;\nconst char *bootdelay_process(void) { char *s; int bootdelay; bootcount_inc(); s = env_get(\u0026#34;bootdelay\u0026#34;);\t//先判断是否有bootdelay环境变量，如果没有，就使用menuconfig中配置的CONFIG_BOOTDELAY时间  bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY; if (IS_ENABLED(CONFIG_OF_CONTROL))\t//是否使用设备树进行配置  bootdelay = fdtdec_get_config_int(gd-\u0026gt;fdt_blob, \u0026#34;bootdelay\u0026#34;, bootdelay); debug(\u0026#34;### main_loop entered: bootdelay=%d\\n\\n\u0026#34;, bootdelay); if (IS_ENABLED(CONFIG_AUTOBOOT_MENU_SHOW)) bootdelay = menu_show(bootdelay); bootretry_init_cmd_timeout(); #ifdef CONFIG_POST  if (gd-\u0026gt;flags \u0026amp; GD_FLG_POSTFAIL) { s = env_get(\u0026#34;failbootcmd\u0026#34;); } else #endif /* CONFIG_POST */ if (bootcount_error()) s = env_get(\u0026#34;altbootcmd\u0026#34;); else s = env_get(\u0026#34;bootcmd\u0026#34;);\t//获取bootcmd环境变量，用于后续的命令执行  if (IS_ENABLED(CONFIG_OF_CONTROL)) process_fdt_options(gd-\u0026gt;fdt_blob); stored_bootdelay = bootdelay; return s; } 2.6.2 autoboot_command #  详细解释标注于代码中\u0026hellip;\u0026hellip;\nvoid autoboot_command(const char *s) { debug(\u0026#34;### main_loop: bootcmd=\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, s ? s : \u0026#34;\u0026lt;UNDEFINED\u0026gt;\u0026#34;); if (stored_bootdelay != -1 \u0026amp;\u0026amp; s \u0026amp;\u0026amp; !abortboot(stored_bootdelay)) { bool lock; int prev; lock = IS_ENABLED(CONFIG_AUTOBOOT_KEYED) \u0026amp;\u0026amp; !IS_ENABLED(CONFIG_AUTOBOOT_KEYED_CTRLC); if (lock) prev = disable_ctrlc(1); /* disable Ctrl-C checking */ run_command_list(s, -1, 0); if (lock) disable_ctrlc(prev);\t/* restore Ctrl-C checking */ } if (IS_ENABLED(CONFIG_USE_AUTOBOOT_MENUKEY) \u0026amp;\u0026amp; menukey == AUTOBOOT_MENUKEY) { s = env_get(\u0026#34;menucmd\u0026#34;); if (s) run_command_list(s, -1, 0); } } 我们看一下判断条件stored_bootdelay != -1 \u0026amp;\u0026amp; s \u0026amp;\u0026amp; !abortboot(stored_bootdelay\n stored_bootdelay：为环境变量的值，或者menuconfig设置的值 s：为环境变量bootcmd的值，为后续运行的指令 abortboot(stored_bootdelay)：主要用于判断是否有按键按下。如果按下，则不执行bootcmd命令，进入cli_loop 命令行模式；如果不按下，则执行bootcmd命令，跳转到加载Linux启动。  2.6.3 cli_loop #  void cli_loop(void) { bootstage_mark(BOOTSTAGE_ID_ENTER_CLI_LOOP); #ifdef CONFIG_HUSH_PARSER  parse_file_outer(); /* This point is never reached */ for (;;);\t//死循环 #elif defined(CONFIG_CMDLINE)  cli_simple_loop(); #else  printf(\u0026#34;## U-Boot command line is disabled. Please enable CONFIG_CMDLINE\\n\u0026#34;); #endif /*CONFIG_HUSH_PARSER*/} 如上代码，程序只执行parse_file_outer来处理用户的输入、输出信息。\n 好啦，基本到这里，我们已经对Uboot的启动流程了然于胸了吧！\n当然，更深层次的不建议去深入了解，有时间可以慢慢去研究。\n 大家有疑问，可以评论区交流\u0026hellip;\u0026hellip;\n参考文章：\n[1]：boadr_init_f介绍\n[2]：启动流程参考\n[3]：main_loop相关\n 欢迎关注【嵌入式艺术】，董哥原创！  "},{"id":7,"href":"/docs/embeded_tech/embeded_interview/","title":"嵌入式面经","section":"嵌入式","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":8,"href":"/docs/linux/linux_debug/","title":"Linux 调试","section":"Linux开发","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":9,"href":"/docs/embeded_tech/self_improve/10w+%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/","title":"【10W+阅读】耗时一周总结的嵌入式学习路线，超详细","section":"嵌入式工程师养成记","content":"【10W+阅读】耗时一周总结的嵌入式学习路线，超详细 #  人们常说：“人生就是一场场游戏，我们要做的，就是打怪，升级，通关”，学习嵌入式的过程也是如此。\n1、前言 #  最近看到知乎上，给我推送了很多类似的回答，借此机会，也想着重新审视一下自己的学习历程，以及结合自身和大牛，分享一些学习经验，希望对大家有所启发和帮助。\n本文主要目的是为了：\n 提供一张嵌入式学习路线地图 提供不同阶段的学习建议 推荐不同阶段的学习资料  3000余字，耗时1周，建议收藏；码字不易，如有帮助，慷慨三连\n 本文将嵌入式学习路线分为几个方面：\n 嵌入式基础必备知识 51单片机 STM32单片机 小而美的RTOS ARM+LINUX   在这个快节奏的时代，能静下心，耐住性子看看文章，实属不易。\n  2、嵌入式基础必备知识 #  老子曰：“合抱之木，生于毫末：九层之台，起于垒土；千里之行，始于足下”，根基的重要性不言而喻。\n那么对于嵌入式这条路线而言，如何建立一个稳固的根基？\n 2.1、学习内容 #   C语言基础  该部分，主要包括几个核心知识点：三大语法结构、常用的数据类型、函数、结构体、指针、文件操作等。\n 硬件基础知识  该部分，核心知识点在于：电路基础知识、数电模电基础知识、常用的电子元器件等。\n 数据结构  核心知识点：数组、队列、链表、堆栈、树、图、散列表等。\n 操作系统  核心知识点：进程管理、内存管理、文件管理、输入输出管理等。\n 计算机原理  核心知识点：数据表示和运算、存储系统、指令系统、总线系统、中央处理器、输入输出系统等。\n 2.2、学习建议 #   对于C语言基础学习，一定要重点熟练掌握，根基的牢固直接决定了我们的代码质量。 对于硬件基础学习，要适当了解，要能够看懂一些简单的电路结构，认识常用的电子元器件。 对于数据结构学习，前五个是必备学习的，可能在刚开始学习的时候，可能会感觉不到作用在哪里，但是随着接触到嵌入式底层设计以及算法设计的时候，才会恍然大悟。 对于操作系统学习，重点学习其思想，对相关知识点有一个大概的了解，后续接触到继续重点学习，这些无论是RTOS，还是Linux，都有涉及到的。 对于计算机原理学习，可以将其看作是嵌入式系统的各个模块的详解，会让你对嵌入式有一个整体的了解，每一个部分都值得深究。   2.3、学习资料 #   C语言基础：推荐经典书籍**《C语言程序设计》（第2版）谭浩强版本**。 硬件基础：大学里面的《数电模电》书籍所涉及的知识即可。 数据结构：推荐经典书籍**《数据结构》——严蔚敏版**。 操作系统、计算机原理：我用的是**《王道》的系列丛书**，个人感觉不错。  计算机组成、数据结构、操作系统、数据库是嵌入式或者说计算机的入门必读书籍，并且也被列入高校教材内，是真正的基础知识。\n 以上，不一定是全部看完才能体验编程的乐趣，这个基础是一个循序渐进的过程，也不是一朝一夕就能完成的，可以先有一个大概，后续做项目时，哪里不懂补哪里！\n这里涉及到一个重要的学习方法：项目导向的学习法。\n 3、嵌入式入门篇——51单片机 #  在上面的基础知识进行熟悉之后（C语言基础、计算机组成、硬件基础必备），我们准备叩开嵌入式世界的大门。\n入门篇，依旧推荐51单片机，当然有人会说，直接上STM32岂不更好？\n我的看法：建议新手还是以51单片机来入门，因为STM32体系架构比51大很多，对于新手刚开始可能会不太容易适应。\n 3.1、学习内容 #  该部分，主要在最小嵌入式系统中，实现各种有趣的实验。通过51单片机的学习，我们要做到：\n 软件类：  主要知识点有：认识单片机、熟悉逻辑运算、点亮一颗LED灯、按键检测、串口通信、定时器、中断等。\n 硬件类：  主要知识点有：电阻元器件了解，基本模块电路了解，时钟电路，尝试绘制51单片机原理图和PCB\n 3.2、学习建议 #   对于软件类，我们主要做到：认识单片机，熟悉单片机的GPIO的输入、输出操作，串口通信协议掌握等，这些部分都是任何一款嵌入式设备的必备技能。 对于硬件类：我们主要做到：能看懂电路图，熟悉一些简单模块的设计电路，了解Altium Designer的使用方法。   3.3、学习资料 #  51单片机：郭天祥的51单片机教程，经典著作，经久不衰，强烈推荐。\n 庄子说：“水之积也不厚，则其负大舟也无力。“\n该部分，是嵌入式领域的基石，只有将基础打牢，才能负得起Linux泰坦号。\n 4、STM32进阶篇 #  STM32是C51的进阶版，拥有C51的基础知识，开发STM32会得心应手。\nSTM32的系统架构以及硬件设计相比于C51来说，都是上升了一个维度的，这也是为什么我推荐入门学习C51的原因。\n 以STM32F407平台为基础，去学习目前嵌入式主流的一些技术，探寻底层的原理，做到不同平台，都能够得心应手。\n 4.1、学习内容 #   基础练习  该部分，主要练习：点亮LED灯、GPIO的输入输出操作、中断操作、UART通信、IIC通信等\n 进阶练习  该部分，主要练习：DMA通信、SPI通信、CAN通信、LCD显示屏，ADC等\n 高阶练习  该部分，主要学习：STM32时钟架构、总线架构、电源管理、代码框架、SDIO通信、USB通信等。\n 4.2、学习建议 #   对于基础练习，主要目的是为了方便让我们从C51到STM32环境的过渡。 对于进阶练习，主要练习一些通信类相关的协议，可以结合一些传感器进行开发。 对于高阶练习，主要目的是为了熟悉单片机的设计架构，编程的框架，以及一些更复杂的通信技术。  另外，STM32会有寄存器和库函数两个版本，建议交叉学习，理解会更加深刻。\n 4.3、学习资料 #  STM32单片机：推荐正点原子、野火的STM32F103或者STM32F407系列。\n两家的学习资料都非常丰富，既有详细的文档说明，也有完整的学习视频教程，非常适合新手入门学习。\n 俗话说：“有道无术，术尚可求，有术无道，止于术”。要明白道和术的区别，不要本末倒置。\n 5、小而美的RTOS #  RTOS，实时操作系统，可以理解为STM32与Linux之间的桥梁，由于其实现思想大都取之于Linux，所以也称之为精简版的Linux。\n我们常用的有实时操作系统有：UCOS，VxWork，FreeRtos，近些年RT-Thread也异军突起。\n学习这些简单的嵌入式系统，一来能够帮助我们为学习Linux操作系统打下基础，二来也能够扩宽我们的职业道路。\n前面也说过了，无论是UCOS、FreeRtos、Rt-thread，其内部的设计思想大同小异，下面主要以Ucos为例。\n5.1、学习内容 #   实时系统学习  该部分，主要学习：移植Ucos系统、多任务管理、调度算法、消息队列、信号量互斥量、事件、内存管理等。\n 5.2、学习建议 #   对于实时系统学习，除了上述的那些核心知识点外，还要结合2.1 基础必备知识的操作系统书籍加深理解。   5.3、学习资料 #  RTOS的学习：依旧推荐正点原子，野火，因为这些实时操作系统开发，可以基于STM32开发板，同时也有非常详细的文档和视频教学。\n 6、ARM+Linux篇 #  学习完RTOS后，基本嵌入式所涉及的技术已经掌握一半了，你也可以独立完成一些小的项目，也可以找到一个不错的工作，但是一定不要自我满足，有机会一定要接触Linux。\n还是那句话：ARM+Linux，也是最为复杂的东西，如果你不去接触Linux，你永远不知道嵌入式的魅力。\n Linux开发又分为驱动开发，内核开发，应用开发，每一个方向都需要几年甚至几十年的积累。\n 作为初学者，我们要做的就是宏观了解，扩大我们的知识面，然后去选择自己感兴趣的方面。\n 6.1、学习内容 #   Linux基础篇  该部分主要学习：Linux常用命令、VIM学习、Linux的Shell编程、Gcc编译、Makefile等。\n 驱动篇  该部分主要学习：内核模块编译原理、字符设备驱动框架、平台设备驱动、设备树、Pinctrl子系统、I2C子系统、中断子系统、块设备驱动框架、Bootloader等\n 内核篇  该部分主要学习：系统调用、存储管理、进程管理、内存管理、文件管理等。\n 应用篇  该部分主要学习：QT编程、TCP/IP协议、HTTP协议等。\n 6.2、学习建议 #   对于基础学习，刚接触到Linux，一般比较难上手，与之前的单片机完全不同，需要一个熟悉环境的过程。 对于驱动学习，重要在于明白“如何在Linux环境下编写驱动程序”，驱动的底层原理还是那样，加了一层层的框架，需要我们去熟悉。 对于内核学习，上述也是系统的几大核心特色，重点在于\u0026quot;如何使Linux性能最优\u0026quot; 对于应用学习，上述的几个方面也是基础，重点还在于开发什么应用，去学习哪方面的知识，没有定论。  对于Linux，有句老话“学习Linux，3年才算入门，5年才勉强算Linux工程师，对于不太熟悉的领域，博主也不敢妄加断言。”\n 6.3、学习资料 #   对于基础学习，推荐**《鸟哥的Linux私房菜》，《Unix环境高级编程》**等入门书籍。 对于驱动开发，推荐**《Linux设备驱动开发详解》**，Linux内核源码详解等。 对于内核学习，推荐**《Linux Shell脚本攻略》、《深入理解Linux内核》**等。 对于应用开发，推荐**《嵌入式Linux应用开发完全手册》、《Unix网络编程》**等。 另外，推荐正点原子，野火，韦东山三个Linux开发教程，韦老师的课程好评居多，但还是看哪个更适合自己。   7、总结 #  全文整体的学习路线：嵌入式基础学习 -\u0026gt; 51单片机 -\u0026gt; STM32单片机 -\u0026gt; RTOS篇 -\u0026gt; ARM+Linux\n每一个部分，也都从学习内容，学习建议，学习资料三个方面来展开，层层深入，步步指引。\n文章既是我的学习历程，又结合了一些大佬的学习分享，不断调整总结出来的，如有异同，可以讨论。\n全文3000余字，耗时1周，如有帮助，望不吝点赞关注。\n最后，文章所涉及的学习资料以及整理的思维导图，全部会在我的星球【嵌入式艺术】分享！\n 欢迎关注【嵌入式艺术】，董哥原创！  "},{"id":10,"href":"/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82ftrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/","title":"【一文秒懂】 Ftrace系统调试工具使用终极指南","section":"Linux 调试","content":"【一文秒懂】Ftrace系统调试工具使用终极指南 #  1、Ftrace是什么 #  Ftrace是Function Trace的简写，由 Steven Rostedt 开发的，从 2008 年发布的内核 2.6.27 中开始就内置了。\nFtrace是一个系统内部提供的追踪工具，旨在帮助内核设计和开发人员去追踪系统内部的函数调用流程。\n随着Ftrace的不断完善，除了追踪函数调用流程外，还可以用来调试和分析系统的延迟和性能问题，并发展成为一个追踪类调试工具的框架。\n除了Ftrace外，追踪类调试工具还包括：\n2、Ftrace的实现原理 #  为了帮助我们更好的使用Ftrace，我们有必要简单了解Ftrace的实现原理。\n2.1 Ftrace框架图 #  Ftrace的框架图如下：\n由框架图我们可以知道：\n ftrace包括多种类型的tracers，每个tracer完成不同的功能 将这些不同类型的tracers注册进入ftrace framework 各类tracers收集不同的信息，并放入到Ring buffer缓冲区以供调用。   2.2 Ftrace是如何记录信息的 #  Ftrace采用了静态插桩和动态插桩两种方式来实现。\n静态插桩：\n我们在Kernel中打开了CONFIG_FUNCTION_TRACER功能后，会增加一个-pg的一个编译选项，这个编译选项的作用就是为每个函数入口处，都会插入bl mcount跳转指令，使得每个函数运行时都会进入mcount函数。\n Ftrace一旦使能，对kernel中所有的函数插桩，这带来的性能开销是惊人的，有可能导致人们弃用Ftrace功能。\n 为了解决这个问题，开发者推出了Dynamic ftrace，以此来优化整体的性能。\n动态插桩：\n 这里的动态，是指的动态修改函数指令。\n  编译时，记录所有被添加跳转指令的函数，这里表示所有支持追踪的函数。 内核将所有跳转指令替换为nop指令，以实现非调试状态性能零损失。 根据 function tracer 设置，动态将被调试函数的nop指令，替换为跳转指令，以实现追踪。   总而言之，Ftrace记录数据可以总结为以下几个步骤：\n 打开编译选项-pg，为每个函数都增加跳转指令 记录这些可追踪的函数，并为了减少性能消耗，将跳转函数替换为nop指令 通过flag标志位来动态管理，将需要追踪的函数预留的nop指令替换回追踪指令，记录调试信息。   3、如何使用Ftrace #  3.1 配置详解 #  CONFIG_FTRACE=y # 启用了 Ftrace CONFIG_FUNCTION_TRACER=y\t# 启用函数级别的追踪器 CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y\t# 表示内核支持图形显示 CONFIG_FUNCTION_GRAPH_TRACER=y\t# 以图形的方式显示函数追踪过程 CONFIG_STACK_TRACER=y\t# 启用堆栈追踪器，用于跟踪内核函数调用的堆栈信息。 CONFIG_DYNAMIC_FTRACE=y\t# 启用动态 Ftrace，允许在运行时启用和禁用 Ftrace 功能。 CONFIG_HAVE_FTRACE_NMI_ENTER=y\t# 表示内核支持非屏蔽中断（NMI）时进入 Ftrace 的功能 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y\t# 表示内核支持通过 mcount 记录函数调用关系。 CONFIG_FTRACE_NMI_ENTER=y # 表示内核支持通过 mcount 记录函数调用关系。  CONFIG_FTRACE_SYSCALLS=y\t# 系统调用的追踪 CONFIG_FTRACE_MCOUNT_RECORD=y\t# 启用 mcount 记录函数调用关系。 CONFIG_SCHED_TRACER=y\t# 支持调度追踪 CONFIG_FUNCTION_PROFILER=y\t# 启用函数分析器，主要用于记录函数的执行时间和调用次数 CONFIG_DEBUG_FS=y\t# 启用 Debug 文件系统支持  上面只是介绍了部分配置，更多详细配置可自行了解。\n并且上述配置不一定全部打开，勾选自己需要的即可，通常我们选择CONFIG_FUNCTION_TRACER和CONFIG_HAVE_FUNCTION_GRAPH_TRACER即可，然后编译烧录到开发板。\n  3.2 挂载debugfs文件系统 #  Ftrace是基于debugfs调试文件系统的，所以我们的第一步就是先挂载debugfs。\nmount -t debugfs none /sys/kernel/debug 此时我们能够在/sys/kernel/debug下看到内核支持的所有的调试信息了。\n# cd /sys/kernel/debug/ # ls asoc gpio regmap bdi ieee80211 sched_debug block memblock sched_features clk mmc0 sleep_time device_component mmc1 suspend_stats devices_deferred mtd tracing dma_buf opp ubi extfrag pinctrl ubifs fault_around_bytes pm_qos wakeup_sources  3.3 traceing目录介绍 #  在/sys/kernel/debug目录下，包含的是kernel所有的调试信息，本章只关注与tracing目录，下面挑选一些比较重要的属性文件来分析。\n  万变不离其宗，如此复杂的框架，设计人员已经提供了README文件，里面详解了各个属性文件的含义，我建议抛弃本文，看README吧:)\n 3.3.1 trace #  trace ：包含当前追踪的内容，以人类可读的格式展现，通过echo \u0026gt; trace来清除。\n 3.3.2 trace_pipe #  trace_pipe 和 trace 一样，都是记录当前的追踪内容，但它和 trace 不一样的是：\n 对 trace_pipe 的读操作将会阻塞，直到有新的追踪数据进来为止； 当前从trace_pipe 读取的内容将被消耗掉，再次读 trace_pipe 又会阻塞到新数据进来为止。   简单的来说，cat trace_pipe是堵塞读取，有数据就读，没数据就等待；而cat trace有没有数据都是直接返回的\n  3.3.3 tracing_on #  tracing_on：向 tracing_on 写入 1，启用追踪；向 tracing_on 写入 0，停止追踪。\n 追踪使用 ring buffer 记录追踪数据。修改 tracing_on 不会影响 ring buffer 当前记录的内容。\n  3.3.4 current_tracer #  current_tracer 表示当前启用的 tracer ，默认为 nop ，即不做任何追踪工作：\n# cat current_tracer nop  3.3.5 available_filter_functions #  available_filter_functions：可以被追踪的函数列表，即可以写到 set_ftrace_filter，set_ftrace_notrace，set_graph_function，set_graph_notrace 文件的函数列表。\n 3.3.6 available_tracers #  available_tracers 文件中包含的是当前编译到内核的 tracer 列表，也表示当前内核支持的tracer列表。\n该列表的内容，就是可以写到 current_tracer 的 tracer 名。\n# cat available_tracers function_graph function nop  nop：表示为空，不追踪 function：追踪函数调用 function_graph：以图形形式追踪函数调用   3.3.7 buffer_size_kb #  buffer_size_kb 记录 CPU buffer 的大小，单位为 KB 。\nper_cpu/cpuX/buffer_size_kb 记录 每个CPU buffer 大小，单位为 KB 。可通过写 buffer_size_kb 来改变 CPU buffer 的大小。\n 3.3.8 buffer_total_size_kb #  buffer_total_size_kb 记录所有 CPU buffer 的总大小，即所有 CPU buffer 大小总和。\n 如有 128 个 CPU buffer ，每个大小 7KB，则 buffer_total_size_kb 记录的总大小为 128 * 7KB = 896。\n buffer_total_size_kb 文件是只读的。\n 3.3.9 set_ftrace_filter #  set_ftrace_filter ：过滤函数追踪，仅仅追踪写入该文件的函数名。\n可填入的参数，可以通过available_filter_functions文件查看当前支持的函数名。\n该过滤功能，也有很多其他变体，如追踪某个模块的函数调用等。\n 官方给的示例：\n Format: :mod:\u0026lt;module-name\u0026gt; example: echo :mod:ext3 \u0026gt; set_ftrace_filter\t# 该模块必须是已经加载进去的模块  3.3.10 set_ftrace_notrace #  set_ftrace_notrace：和 set_ftrace_filter 刚好相反，系统禁用对其中列举函数的追踪。\n 3.3.11 set_ftrace_pid #  系统对 set_ftrace_pid 文件中指定的 PID进程进行追踪。\n如果开启了 options/function-fork 选项，fork 的子进程的 PID 也会自动加入文件，同时该选项也会引起系统自动将退出进程的 PID 从文件中移除。\n 3.3.12 set_graph_function #  此文件中列出的函数将导致函数图跟踪器仅跟踪这些函数以及它们调用的函数。\n但是该跟踪的记录，仍然受set_ftrace_filter 和 set_ftrace_notrace 的影响。\n 3.3.12 set_graph_notrace #  与 set_graph_function 类似，但当函数被命中时，将禁用函数图跟踪，直到退出函数。\n 3.4 简单使用示例 #   一般我们挂载上debugfs后，tracing_on是处于打开状态的。\n 3.4.1 函数追踪 #   3.4.2 追踪图形显示 #   3.4.3 动态过滤追踪 #   3.4.4 重置追踪 #  echo 0 \u0026gt; tracing_on\t# 关闭trace echo \u0026gt; trace\t# 清空当前trace记录 cat available_tracers # 查看当前支持的追踪类型 echo function_graph \u0026gt; current_tracer # 设置当前的追踪类型 echo 1 \u0026gt; tracing_on\t# 开启追踪 cat trace\t# 查看追踪结果  4、进阶用法 #  上述章节，只是介绍了Ftrace最基本的命令，下面来看一下Ftrace在具体问题中的用法！\n4.1 追踪任意命令 #   如何追踪我们执行的命令呢？\n Ftrace支持追踪特定进程，通过set_ftrace_pid属性来设置指定进程。然后在该进程中，执行特定的命令。\n首先我们需要设置好我们的追踪器\nmount -t debugfs none /sys/kernel/debug cd /sys/kernel/debug/tracing echo 0 \u0026gt; tracing_on\t# 关闭追踪器 echo function \u0026gt; current_tracer\t# 设置当前追踪类别 在我们设置好追踪器后，使用如下命令，即可追踪我们执行的命令your_command\necho \u0026gt; trace; echo $$ \u0026gt; set_ftrace_pid; echo 1 \u0026gt; tracing_on; your_command; echo 0 \u0026gt; tracing_on  4.2 追踪指定函数的调用流程 #  跟踪函数的时候，设置 echo 1 \u0026gt; options/func_stack_trace 即可在 trace 结果中获取追踪函数的调用栈。\nmount -t debugfs none /sys/kernel/debug cd /sys/kernel/debug/tracing echo 0 \u0026gt; tracing_on\t# 关闭追踪器 cat available_filter_functions | grep \u0026#34;xxxxxx\u0026#34;\t# 搜索函数是否存在 echo xxxxxx \u0026gt; set_ftrace_filter\t# 设定追踪的函数 echo function \u0026gt; current_tracer\t# 设置当前追踪类别 echo 1 \u0026gt; options/func_stack_trace\t# 记录堆栈信息 echo \u0026gt; trace\t# 清空缓存 echo 1 \u0026gt; tracing_on\t# 开始追踪 效果如下：\n# cat trace # tracer: function # # entries-in-buffer/entries-written: 2/2 #P:3 # # _-----=\u0026gt; irqs-off # / _----=\u0026gt; need-resched # | / _---=\u0026gt; hardirq/softirq # || / _--=\u0026gt; preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | kworker/1:1-59 [001] .... 168.954199: mmc_rescan \u0026lt;-process_one_work kworker/1:1-59 [001] .... 168.954248: \u0026lt;stack trace\u0026gt; =\u0026gt; mmc_rescan =\u0026gt; process_one_work =\u0026gt; worker_thread =\u0026gt; kthread =\u0026gt; ret_from_fork =\u0026gt; 0  4.3 追踪指定模块的所有函数 #  要想我们的ko文件能够被Ftrace记录到，我们需要在编译模块的时候，加上编译参数-pg，这点很重要，否则你在available_filter_functions列表中，查找不到你想要的函数。\n然后，需要我们设置过滤器，设置方法有以下几种：\n 按模块直接过滤：  # 示例 Format: :mod:\u0026lt;module-name\u0026gt; example: echo :mod:ext3 \u0026gt; set_ftrace_filter  追踪ext3模块内的所有函数\n   按函数直接过滤   如果该模块内的函数，命名都有一定的规则，可以按照正则表达式来过滤\n # 示例 echo \u0026#34;mmc*\u0026#34; \u0026gt; set_ftrace_filter  过滤包含mmc字符的所有函数\n   按照函数差异来过滤  如果函数命名没有规律，又想过滤该模块所有函数，该怎么办？\n按照加载模块前后的函数差异，写入到文件中来过滤\ncat available_filter_functions \u0026gt; /tmp/1.txt cat available_filter_functions \u0026gt; /tmp/2.txt diff /tmp/1.txt /tmp/2.txt \u0026gt; /tmp/3.txt cat /tmp/3.txt | sed \u0026#39;s/^+//\u0026#39; | awk \u0026#39;{print $1}\u0026#39;\t# 如果diff出来格式前带有+-号，需要手动去掉 cat /tmp/3.txt \u0026gt; set_ftrace_filter  5、自动化管理 #  Ftrace功能很强大，在内核层面我们通过echo和cat即可获取我们想要的所有信息，但是通过一次一次敲命令显得有些繁琐，自己也对常用的功能整合了一个自动化脚本，能够通过命令行，直接追踪特定模块、函数、命令，极大提高了调试效率。\n自动化脚本获取路径：common_trace.sh\n# /root/common_trace.sh  Usage: /root/common_trace.sh {module|funcs|funcs_stack|command|clear} /root/common_trace.sh module ext4 /root/common_trace.sh funcs sysfs /root/common_trace.sh funcs_stack sysfs /root/common_trace.sh command sysfs [functions] /root/common_trace.sh clear 脚本主要实现的功能有：\n 追踪指定模块，查看所有调用流程 追踪指定函数，查看该函数的调用链 追踪指定函数，获取堆栈信息 追踪用户命令，查看所有调用流程，并可选择指定函数来查看调用流程。   脚本除了command功能外，其他功能都需要手动调用common_trace.sh clear来停止追踪。\n  6、总结 #  以上，介绍了Ftrace的由来，实现原理，以及如何使用Ftrace，并最终提供了自动化测试脚本，希望对大家有所帮助。\n 欢迎关注【嵌入式艺术】，董哥原创！\r\u0026nbsp;"},{"id":11,"href":"/about/index-zh/","title":"About","section":"Abouts","content":"1、个人介绍 #  🙍🏻‍♂️ 大家好，我是董哥，一名工作多年的嵌入式Linux开发工程师。以下是我的基本信息介绍：\n 参加全国机器人大赛（Robocon），两次获得全国一等奖 毕业后斩获科沃斯，石头，格力等多家头部机器人公司的offer，后入职世界五百强格力电器担任嵌入式开发工程师 现今就职于独角兽芯片企业，担任嵌入式Linux驱动开发工程师 熟练使用C/C++语言开发，熟悉各类MCU开发，如STM32，ARM，SOC等，熟悉Ucos，RT-thread实时操作系统等 目前主要负责Linux驱动，系统开发，WiFi\u0026amp;BT开发等相关工作，同时跟进并参与多款百万级量产项目的研发。 荣获优质嵌入式领域创作者称号，拿下2022年度博客之星嵌入式领域TOP 5，全网收获超百万读者。  2、技术与分享 #  记录Blog是一项值得挑战的事情，一方面是对自我技术的沉淀，另一方面也是四万万嵌入式开发者前行路上的加速剂；并且网上大多数文章七零八落，每个人对技术的理解程度不同，因此好的文章，永不过时！\n我的一些自媒体平台：\n CSDN：卍一十二画卍 知乎：嵌入式艺术 公众号：嵌入式艺术 知识星球：嵌入式艺术  3、我的星球 #  🚩 【嵌入式艺术】星球，目前是处于起步阶段，我们的目标是：携手共创高质量的嵌入式基地，兼收并蓄，群英荟萃，实现升职加薪创业梦！\n🛎️ 我们提供的服务有：\n 提供一个高级嵌入式工程师聚集地，聚焦嵌入式工程师成长与发展。 高质量嵌入式项目、技术的拆解与分析 高效率的嵌入式开发工具分享 AIGC + 嵌入式 应用，跟上时代的脚步 嵌入式的行业趋势与热点分析  🛎️ 我们后续要做的事情：\n 引入更多嵌入式领域大咖加入我们的星球，为大家提供更好的服务！ 引入更多优质公司的内推岗位，以便大家走内部推荐通道，加入头部企业！ 拆解更多嵌入式项目，为大家提供实战经验，以目标为导向，实现更好的学习效果！ 星球不定期举办激励活动，有实物激励以及现金激励两种，希望大家踊跃参加！  "}]