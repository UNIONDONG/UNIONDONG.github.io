<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Linux内存管理 | 二、虚拟地址空间布局 #  上一章，我们了解了内存管理的由来以及核心思想，下面我们按照顺序，先来介绍一下Linux虚拟内存空间的管理。
 同样，我们知道Linux内核抽象出来虚拟内存空间，主要是为了让每个进程都独享该空间，那虚拟内存空间是如何布局的呢？
 前提：针对于不同位数的CPU，寻址能力不同，抽象出来的虚拟内存空间大小也不同，我们以常见的32位的CPU为例。
  1、虚拟内存空间布局 #  对于32位的CPU，寻址范围为0~2^32，也就是0x00000000-0xFFFFFFFF，即最多抽象出来4G的虚拟内存空间。
这4GB的内存空间，在Linux中，又分为用户空间和内核空间，其中0x0000000-0xBFFFFFFF，共3G为用户空间，0xC00000000-0xFFFFFFFF，共1G为内核空间，如下：
无论内核空间还是用户空间，其仍然是在虚拟内存空间基础之上进行划分的，其直接访问的依旧都是虚拟地址，而非物理地址！
我们编写代码后，所生成的可执行程序，运行之后就成为一个系统进程，我们在&quot;虚&quot;的角度来看，每个进程都是独享这4G虚拟地址空间的，
 2、用户态空间布局 #  如上所述，用户空间在虚拟内存中分布在0x0000000-0xBFFFFFFF，大小为3G。
每一个用户进程，按照访问属性一致的地址空间存放在一起的原则，划分成5个不同的内存区域（访问属性一致指的是：可读，可写，可执行）：
 代码段：Text Segment，也就是我们的二进制程序，代码段需要防止在运行时被非法修改，所以该段为只读。 数据段：Data Segment，主要存放初始化了的变量，主要包括：静态变量和全局变量，该段为读写。 BSS段：BSS Segment，主要存放未初始化的全局变量，在内存中 bss 段全部置零，该段为读写。 堆段：Heap Segment，主要存放进程运行过程中动态分配的内存段，大小不固定，可动态扩张和缩减，通常使用malloc和free来分配释放，并且堆的增长方向是向上的。 文件映射和匿名映射段：Memory Mapping Segment，主要存放进程使用到的文件或者依赖的动态库，从低地址向上增长。 栈段：Stack Segment，主要存放进程临时创建的局部变量，函数调用上下文信息等，栈向下增长。  一个可执行程序，可以通过size命令，查看编译出来的可执行文件大小，其中包括了代码段，数据段等数据信息，如下:
donge@Donge:$ size Donge-Demo text data bss dec hex filename 12538 1916 43632 58086 e2e6 Donge-Demo  text：代码段大小 data：数据段大小 bss：bss段大小 dec：十进制表示的可执行文件大小 hex：十六进制表示的可执行文件大小   运行该程序后，可以通过cat /proc/PID/maps命令，或者pmap PID命令，来查看该进程在虚拟内存空间中的分配情况，其中PID为进程的PID号，如下:
donge@Donge:$ cat /proc/16508/maps 55976ff9e000-55976ffa0000 r--p 00000000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa0000-55976ffa2000 r-xp 00002000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa2000-55976ffa3000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa3000-55976ffa4000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa4000-55976ffa5000 rw-p 00005000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa5000-55976ffaf000 rw-p 00000000 00:00 0 559771d91000-559771db2000 rw-p 00000000 00:00 0 [heap] 7fec1ad84000-7fec1ad87000 rw-p 00000000 00:00 0 7fec1ad87000-7fec1adaf000 r--p 00000000 08:10 22282 /usr/lib/x86_64-linux-gnu/libc.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="二、虚拟地址空间布局" />
<meta property="og:description" content="Linux内存管理 | 二、虚拟地址空间布局 #  上一章，我们了解了内存管理的由来以及核心思想，下面我们按照顺序，先来介绍一下Linux虚拟内存空间的管理。
 同样，我们知道Linux内核抽象出来虚拟内存空间，主要是为了让每个进程都独享该空间，那虚拟内存空间是如何布局的呢？
 前提：针对于不同位数的CPU，寻址能力不同，抽象出来的虚拟内存空间大小也不同，我们以常见的32位的CPU为例。
  1、虚拟内存空间布局 #  对于32位的CPU，寻址范围为0~2^32，也就是0x00000000-0xFFFFFFFF，即最多抽象出来4G的虚拟内存空间。
这4GB的内存空间，在Linux中，又分为用户空间和内核空间，其中0x0000000-0xBFFFFFFF，共3G为用户空间，0xC00000000-0xFFFFFFFF，共1G为内核空间，如下：
无论内核空间还是用户空间，其仍然是在虚拟内存空间基础之上进行划分的，其直接访问的依旧都是虚拟地址，而非物理地址！
我们编写代码后，所生成的可执行程序，运行之后就成为一个系统进程，我们在&quot;虚&quot;的角度来看，每个进程都是独享这4G虚拟地址空间的，
 2、用户态空间布局 #  如上所述，用户空间在虚拟内存中分布在0x0000000-0xBFFFFFFF，大小为3G。
每一个用户进程，按照访问属性一致的地址空间存放在一起的原则，划分成5个不同的内存区域（访问属性一致指的是：可读，可写，可执行）：
 代码段：Text Segment，也就是我们的二进制程序，代码段需要防止在运行时被非法修改，所以该段为只读。 数据段：Data Segment，主要存放初始化了的变量，主要包括：静态变量和全局变量，该段为读写。 BSS段：BSS Segment，主要存放未初始化的全局变量，在内存中 bss 段全部置零，该段为读写。 堆段：Heap Segment，主要存放进程运行过程中动态分配的内存段，大小不固定，可动态扩张和缩减，通常使用malloc和free来分配释放，并且堆的增长方向是向上的。 文件映射和匿名映射段：Memory Mapping Segment，主要存放进程使用到的文件或者依赖的动态库，从低地址向上增长。 栈段：Stack Segment，主要存放进程临时创建的局部变量，函数调用上下文信息等，栈向下增长。  一个可执行程序，可以通过size命令，查看编译出来的可执行文件大小，其中包括了代码段，数据段等数据信息，如下:
donge@Donge:$ size Donge-Demo text data bss dec hex filename 12538 1916 43632 58086 e2e6 Donge-Demo  text：代码段大小 data：数据段大小 bss：bss段大小 dec：十进制表示的可执行文件大小 hex：十六进制表示的可执行文件大小   运行该程序后，可以通过cat /proc/PID/maps命令，或者pmap PID命令，来查看该进程在虚拟内存空间中的分配情况，其中PID为进程的PID号，如下:
donge@Donge:$ cat /proc/16508/maps 55976ff9e000-55976ffa0000 r--p 00000000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa0000-55976ffa2000 r-xp 00002000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa2000-55976ffa3000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa3000-55976ffa4000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa4000-55976ffa5000 rw-p 00005000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa5000-55976ffaf000 rw-p 00000000 00:00 0 559771d91000-559771db2000 rw-p 00000000 00:00 0 [heap] 7fec1ad84000-7fec1ad87000 rw-p 00000000 00:00 0 7fec1ad87000-7fec1adaf000 r--p 00000000 08:10 22282 /usr/lib/x86_64-linux-gnu/libc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2024-01-17T21:13:17+08:00" />
<meta property="article:modified_time" content="2024-01-17T21:13:17+08:00" />

<title>二、虚拟地址空间布局 | Donge Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.b4994b30da00cde195711ceaee8eafa9408349f5b74d152668b819d660720d7b.js" integrity="sha256-tJlLMNoAzeGVcRzq7o6vqUCDSfW3TRUmaLgZ1mByDXs=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/img/logo.png" alt="Logo" /><span>Donge Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://blog.csdn.net/dong__ge"  target="_blank" rel="noopener">
        CSDN
      </a>
  </li>
  
  <li>
    <a href="https://www.zhihu.com/people/Embedded_Art"  target="_blank" rel="noopener">
        知乎
      </a>
  </li>
  
  <li>
    <a href="https://github.com/UNIONDONG"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="/about/index_zh/"  >
        About
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>嵌入式</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3ebd3b438738bd5ab63f55999004f0e7" class="toggle"  />
    <label for="section-3ebd3b438738bd5ab63f55999004f0e7" class="flex justify-between">
      <a href="/docs/embeded_tech/self_improve/" class="">嵌入式工程师养成记</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/self_improve/10w&#43;%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/" class="">【10W&#43;阅读】耗时一周总结的嵌入式学习路线，超详细</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-979254fc07de711332325335a96d33d1" class="toggle"  />
    <label for="section-979254fc07de711332325335a96d33d1" class="flex justify-between">
      <a href="/docs/embeded_tech/embeded_interview/" class="">嵌入式面经</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/" class="">Soc的Bring Up流程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/" class="">CPU体系架构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="">Linux用户态和内核态交互的几种方式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Uboot开发</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/" class="">一、uboot基础了解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="">二、uboot启动流程分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%B8%89uboot%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/" class="">三、Uboot驱动模型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E5%9B%9Buboot%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" class="">四、Uboot命令行模式分析</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Linux开发</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3eeeb8a1a5c1ce449ec7070209d774d9" class="toggle"  />
    <label for="section-3eeeb8a1a5c1ce449ec7070209d774d9" class="flex justify-between">
      <a href="/docs/linux/linux_api/" class="">Linux API 揭秘</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/" class="">【Linux API 揭秘】module_init与module_exit</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" class="">【Linux API 揭秘】container_of函数详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-cad08b32e77ccfb31b07972873519838" class="toggle"  />
    <label for="section-cad08b32e77ccfb31b07972873519838" class="flex justify-between">
      <a role="button" class="">Linux 调试工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82ftrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" class="">【一文秒懂】Ftrace系统调试工具使用终极指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="">【一文秒懂】TOP命令详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b3bfa0c2506d9fd89a39b0698e122f31" class="toggle" checked />
    <label for="section-b3bfa0c2506d9fd89a39b0698e122f31" class="flex justify-between">
      <a role="button" class="">Linux 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/" class="">一、内存管理的由来及思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/" class="active">二、虚拟地址空间布局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/" class="">三、虚拟地址空间管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/" class="">四、物理地址空间设计模型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/" class="">五、物理内存空间布局及管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" class="">六、物理内存分配——伙伴系统</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2455edf5b3ea22c6053a61d28029cb9a" class="toggle"  />
    <label for="section-2455edf5b3ea22c6053a61d28029cb9a" class="flex justify-between">
      <a role="button" class="">Linux 内核锁详解</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%80%E5%86%85%E6%A0%B8%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5/" class="">【深入理解Linux锁机制】一、内核锁的由来</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%8C%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD/" class="">【深入理解Linux锁机制】二、中断屏蔽</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="">【深入理解Linux锁机制】三、原子操作</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%9B%9B%E8%87%AA%E6%97%8B%E9%94%81/" class="">【深入理解Linux锁机制】四、自旋锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%94%E8%A1%8D%E7%94%9F%E8%87%AA%E6%97%8B%E9%94%81/" class="">【深入理解Linux锁机制】五、衍生自旋锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AD%E4%BF%A1%E5%8F%B7%E9%87%8F/" class="">【深入理解Linux锁机制】六、信号量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%83%E4%BA%92%E6%96%A5%E4%BD%93/" class="">【深入理解Linux锁机制】七、互斥体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E5%AE%8C%E6%88%90%E9%87%8F/" class="">【深入理解Linux锁机制】八、完成量</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3e346f9c1e7b71569b8cd088121d9787" class="toggle"  />
    <label for="section-3e346f9c1e7b71569b8cd088121d9787" class="flex justify-between">
      <a role="button" class="">Linux NVMEM 子系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%80efuse%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8%E6%B5%85%E6%9E%90/" class="">【NVMEM子系统深入剖析】一、Efuse介绍及安全启动浅析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%BA%8Cnvmem%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/" class="">【NVMEM子系统深入剖析】二、NVMEM驱动框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%89%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%9C%A8%E5%85%B3%E8%81%94/" class="">【NVMEM子系统深入剖析】三、核心数据结构及内在关联</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9Befuse%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/" class="">【NVMEM子系统深入剖析】四、efuse驱动实现流程</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>二、虚拟地址空间布局</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#linux内存管理--二虚拟地址空间布局">Linux内存管理 | 二、虚拟地址空间布局</a>
      <ul>
        <li><a href="#1虚拟内存空间布局">1、虚拟内存空间布局</a></li>
        <li><a href="#2用户态空间布局">2、用户态空间布局</a></li>
        <li><a href="#3内核态空间布局">3、内核态空间布局</a></li>
        <li><a href="#4总结">4、总结</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="linux内存管理--二虚拟地址空间布局">
  Linux内存管理 | 二、虚拟地址空间布局
  <a class="anchor" href="#linux%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86--%e4%ba%8c%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80">#</a>
</h1>
<p>上一章，我们了解了内存管理的由来以及核心思想，下面我们按照顺序，先来介绍一下<code>Linux</code>虚拟内存空间的管理。</p>
<p> </p>
<p>同样，我们知道<code>Linux</code>内核抽象出来虚拟内存空间，主要是为了让每个进程都独享该空间，那虚拟内存空间是如何布局的呢？</p>
<blockquote>
<p><strong>前提</strong>：针对于不同位数的<code>CPU</code>，寻址能力不同，抽象出来的虚拟内存空间大小也不同，我们以常见的<code>32</code>位的<code>CPU</code>为例。</p>
</blockquote>
<p> </p>
<h2 id="1虚拟内存空间布局">
  1、虚拟内存空间布局
  <a class="anchor" href="#1%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80">#</a>
</h2>
<p>对于<code>32</code>位的<code>CPU</code>，寻址范围为<code>0~2^32</code>，也就是<code>0x00000000-0xFFFFFFFF</code>，即最多抽象出来<code>4G</code>的虚拟内存空间。</p>
<p>这<code>4GB</code>的内存空间，在<code>Linux</code>中，又分为<strong>用户空间和内核空间</strong>，其中<code>0x0000000-0xBFFFFFFF</code>，共<code>3G</code>为用户空间，<code>0xC00000000-0xFFFFFFFF</code>，共<code>1G</code>为内核空间，如下：</p>
<p><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20230924173124939.png" alt="image-20230924173124939" /></p>
<p><font color = "red"><strong>无论内核空间还是用户空间，其仍然是在虚拟内存空间基础之上进行划分的，其直接访问的依旧都是虚拟地址，而非物理地址！</strong></font></p>
<p>我们编写代码后，所生成的可执行程序，运行之后就成为一个系统进程，我们在&quot;虚&quot;的角度来看，每个进程都是独享这<code>4G</code>虚拟地址空间的，</p>
<p> </p>
<h2 id="2用户态空间布局">
  2、用户态空间布局
  <a class="anchor" href="#2%e7%94%a8%e6%88%b7%e6%80%81%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80">#</a>
</h2>
<p>如上所述，用户空间在虚拟内存中分布在<code>0x0000000-0xBFFFFFFF</code>，大小为<code>3G</code>。</p>
<p>每一个用户进程，按照<strong>访问属性一致的地址空间存放在一起</strong>的原则，划分成5个不同的内存区域（访问属性一致指的是：可读，可写，可执行）：</p>
<ul>
<li><strong>代码段</strong>：<code>Text Segment</code>，也就是我们的二进制程序，代码段需要防止在运行时被非法修改，<strong>所以该段为只读</strong>。</li>
<li><strong>数据段</strong>：<code>Data Segment</code>，主要存放初始化了的变量，主要包括：静态变量和全局变量，<strong>该段为读写</strong>。</li>
<li><strong><code>BSS</code>段</strong>：<code>BSS Segment</code>，主要存放未初始化的全局变量，在内存中 <code>bss</code> 段全部置零，<strong>该段为读写</strong>。</li>
<li><strong>堆段</strong>：<code>Heap Segment</code>，主要存放进程运行过程中动态分配的内存段，大小不固定，可动态扩张和缩减，通常使用<code>malloc</code>和<code>free</code>来分配释放，并且堆的增长方向是向上的。</li>
<li><strong>文件映射和匿名映射段</strong>：<code>Memory Mapping Segment</code>，主要存放进程使用到的文件或者依赖的动态库，从低地址向上增长。</li>
<li><strong>栈段</strong>：<code>Stack Segment</code>，主要存放进程临时创建的局部变量，函数调用上下文信息等，栈向下增长。</li>
</ul>
<p><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231005160139650.png" alt="image-20231005160139650" /></p>
<p><font color = "red"><strong>一个可执行程序，可以通过<code>size</code>命令，查看编译出来的可执行文件大小，其中包括了代码段，数据段等数据信息，如下:</strong></font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">donge@Donge:$ size Donge-Demo
   text    data     bss     dec     hex filename
  <span style="color:#bd93f9">12538</span>    <span style="color:#bd93f9">1916</span>   <span style="color:#bd93f9">43632</span>   <span style="color:#bd93f9">58086</span>    e2e6 Donge-Demo
</code></pre></div><ul>
<li><code>text</code>：代码段大小</li>
<li><code>data</code>：数据段大小</li>
<li><code>bss</code>：<code>bss</code>段大小</li>
<li><code>dec</code>：十进制表示的可执行文件大小</li>
<li><code>hex</code>：十六进制表示的可执行文件大小</li>
</ul>
<p> </p>
<p><font color = "red"><strong>运行该程序后，可以通过<code>cat /proc/PID/maps</code>命令，或者<code>pmap PID</code>命令，来查看该进程在虚拟内存空间中的分配情况，其中PID为进程的PID号，如下:</strong></font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">donge@Donge:$ cat /proc/16508/maps
55976ff9e000-55976ffa0000 r--p <span style="color:#bd93f9">00000000</span> 08:10 <span style="color:#bd93f9">184922</span>                     /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo
55976ffa0000-55976ffa2000 r-xp <span style="color:#bd93f9">00002000</span> 08:10 <span style="color:#bd93f9">184922</span>                     /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo
55976ffa2000-55976ffa3000 r--p <span style="color:#bd93f9">00004000</span> 08:10 <span style="color:#bd93f9">184922</span>                     /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo
55976ffa3000-55976ffa4000 r--p <span style="color:#bd93f9">00004000</span> 08:10 <span style="color:#bd93f9">184922</span>                     /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo
55976ffa4000-55976ffa5000 rw-p <span style="color:#bd93f9">00005000</span> 08:10 <span style="color:#bd93f9">184922</span>                     /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo
55976ffa5000-55976ffaf000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>
559771d91000-559771db2000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>                          <span style="color:#ff79c6">[</span>heap<span style="color:#ff79c6">]</span>
7fec1ad84000-7fec1ad87000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>
7fec1ad87000-7fec1adaf000 r--p <span style="color:#bd93f9">00000000</span> 08:10 <span style="color:#bd93f9">22282</span>                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fec1adaf000-7fec1af44000 r-xp <span style="color:#bd93f9">00028000</span> 08:10 <span style="color:#bd93f9">22282</span>                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fec1af44000-7fec1af9c000 r--p 001bd000 08:10 <span style="color:#bd93f9">22282</span>                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fec1af9c000-7fec1afa0000 r--p <span style="color:#bd93f9">00214000</span> 08:10 <span style="color:#bd93f9">22282</span>                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fec1afa0000-7fec1afa2000 rw-p <span style="color:#bd93f9">00218000</span> 08:10 <span style="color:#bd93f9">22282</span>                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fec1afa2000-7fec1afaf000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>
7fec1afb5000-7fec1afb7000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>
7fec1afb7000-7fec1afb9000 r--p <span style="color:#bd93f9">00000000</span> 08:10 <span style="color:#bd93f9">22068</span>                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fec1afb9000-7fec1afe3000 r-xp <span style="color:#bd93f9">00002000</span> 08:10 <span style="color:#bd93f9">22068</span>                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fec1afe3000-7fec1afee000 r--p 0002c000 08:10 <span style="color:#bd93f9">22068</span>                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fec1afef000-7fec1aff1000 r--p <span style="color:#bd93f9">00037000</span> 08:10 <span style="color:#bd93f9">22068</span>                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fec1aff1000-7fec1aff3000 rw-p <span style="color:#bd93f9">00039000</span> 08:10 <span style="color:#bd93f9">22068</span>                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffce385d000-7ffce387e000 rw-p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>                          <span style="color:#ff79c6">[</span>stack<span style="color:#ff79c6">]</span>
7ffce394e000-7ffce3952000 r--p <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>                          <span style="color:#ff79c6">[</span>vvar<span style="color:#ff79c6">]</span>
7ffce3952000-7ffce3953000 r-xp <span style="color:#bd93f9">00000000</span> 00:00 <span style="color:#bd93f9">0</span>                          <span style="color:#ff79c6">[</span>vdso<span style="color:#ff79c6">]</span>
</code></pre></div><p>上面能大致看出该进程的代码段、堆、文件映射段，栈的内存分布等情况，以上就是我们的可执行程序被加载进入内存之后，在用户态虚拟内存空间的布局情况。</p>
<p> </p>
<blockquote>
<p>顺便介绍一下 我的圈子：<a href="https://t.zsxq.com/0eUcTOhdO">高级工程师聚集地</a>，期待大家的加入。</p>
</blockquote>
<h2 id="3内核态空间布局">
  3、内核态空间布局
  <a class="anchor" href="#3%e5%86%85%e6%a0%b8%e6%80%81%e7%a9%ba%e9%97%b4%e5%b8%83%e5%b1%80">#</a>
</h2>
<p>下面我们来看一下内核态的虚拟空间布局，首先我们要知道：</p>
<ol>
<li>在<code>Linux</code>系统中，用户进程通常只能访问用户空间的虚拟地址，只有在执行内陷操作或系统调用时才能访问内核空间。</li>
<li>所有的进程通过系统调用进入内核态之后，看到的虚拟地址空间都是一样的，他们是共享内核态虚拟内存空间的。</li>
</ol>
<p> </p>
<p><strong>32位的内核态虚拟空间在虚拟内存中分布在<code>0xC00000000-0xFFFFFFFF</code>上，大小为<code>1G</code>，其要分为以下几个区</strong>：</p>
<ul>
<li><strong>直接映射区（<code>Direct Memory Region</code>）</strong>：顾名思义，直接映射区就是直接与物理内存建立一一映射关系。从内核空间起始地址开始，到<code>896M</code>的内核空间地址区间，为直接内存映射区，该区域线性地址和分配的物理地址都是连续的。</li>
</ul>
<blockquote>
<p><code>896M</code>以上的内核地址空间，又称为高端内存区域。</p>
</blockquote>
<ul>
<li>
<p><strong>安全保护区</strong>：也成为内存空洞，大小为<code>8M</code>，其主要目的是为了避免 非连续区的非法访问，</p>
</li>
<li>
<p><strong>动态映射区</strong>：也就是<code>vmalloc Region</code>，该区域由<code>Vmalloc</code>函数分配，特点是：虚拟地址空间连续，但是物理地址空间不一定连续。</p>
</li>
<li>
<p><strong>永久映射区（<code>Persistent Kernel Mapping Region</code>）</strong>：该区域主要用于访问高端内存，通过<code>alloc_page (_GFP_HIGHMEM)</code>接口分配高端内存页，可以使用<code>kmap</code>函数将分配到的高端内存映射到该区域。</p>
</li>
<li>
<p><strong>固定映射区（<code>Fixing kernel Mapping Region</code>）</strong>：该区域虚拟内存地址可以自由映射到物理内存的高端地址上，“固定”表现在“虚拟内存空间地址是固定的”，被映射的物理地址是可变的。</p>
</li>
</ul>
<blockquote>
<p>为什么会有固定映射这个概念呢 ?</p>
<p>比如：在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去。</p>
</blockquote>
<p><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231005155942462.png" alt="image-20231005155942462" /></p>
<h2 id="4总结">
  4、总结
  <a class="anchor" href="#4%e6%80%bb%e7%bb%93">#</a>
</h2>
<p>以上就是整个虚拟地址空间的划分，总结如下：</p>
<p><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20231005160802093.png" alt="image-20231005160802093" /></p>
<center><b> <font color ="blue">欢迎关注【嵌入式艺术】，董哥原创！</font></b></center>
<div align=center><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/blog.png" alt="img" width = "60%" height ="10%"/>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){if(window.getSelection().toString())return;a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#linux内存管理--二虚拟地址空间布局">Linux内存管理 | 二、虚拟地址空间布局</a>
      <ul>
        <li><a href="#1虚拟内存空间布局">1、虚拟内存空间布局</a></li>
        <li><a href="#2用户态空间布局">2、用户态空间布局</a></li>
        <li><a href="#3内核态空间布局">3、内核态空间布局</a></li>
        <li><a href="#4总结">4、总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












