<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="【LED子系统深度剖析】四、核心层详解（一） #  1、前言 #   上篇文章我们了解了子系统的硬件驱动层，下面我们来分析驱动框架中核心层的实现以及作用。
 在LED子系统框架中，核心层包括几个部分：核心层的实现部分（led-core.c）、sysfs文件节点创建（led-class.c）、触发功能实现(led-triggers.c、driver/leds/triggers/led-xxx.c)
 其中，触发功能部分较为独立，我们暂且先不去分析。
 我们先从led-class.c文件开始分析
2、leds_init分析 #   该函数其主要是为了创建LED设备文件节点，方便用户通过节点直接访问。
 该文件，我们直接拉下底部，我们直接看入口函数：leds_init
2.1 相关数据结构 #  2.1.1 class #  /** * struct class - device classes * @name:	Name of the class. * @owner:	The module owner. * @class_groups: Default attributes of this class. * @dev_groups:	Default attributes of the devices that belong to the class. * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="【LED子系统深度剖析】四、核心层详解（一）" />
<meta property="og:description" content="【LED子系统深度剖析】四、核心层详解（一） #  1、前言 #   上篇文章我们了解了子系统的硬件驱动层，下面我们来分析驱动框架中核心层的实现以及作用。
 在LED子系统框架中，核心层包括几个部分：核心层的实现部分（led-core.c）、sysfs文件节点创建（led-class.c）、触发功能实现(led-triggers.c、driver/leds/triggers/led-xxx.c)
 其中，触发功能部分较为独立，我们暂且先不去分析。
 我们先从led-class.c文件开始分析
2、leds_init分析 #   该函数其主要是为了创建LED设备文件节点，方便用户通过节点直接访问。
 该文件，我们直接拉下底部，我们直接看入口函数：leds_init
2.1 相关数据结构 #  2.1.1 class #  /** * struct class - device classes * @name:	Name of the class. * @owner:	The module owner. * @class_groups: Default attributes of this class. * @dev_groups:	Default attributes of the devices that belong to the class. * @dev_kobj:	The kobject that represents this class and links it into the hierarchy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%9B%9B%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%80/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2024-01-19T20:29:24+08:00" />
<meta property="article:modified_time" content="2024-01-19T20:29:24+08:00" />

<title>【LED子系统深度剖析】四、核心层详解（一） | Donge Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.b5775eee0b743844194ef6e7bbcd3f5283e5661d599025542fbabfb59441ad57.js" integrity="sha256-tXde7gt0OEQZTvbnu80/UoPlZh1ZkCVUL7q/tZRBrVc=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/img/logo.png" alt="Logo" /><span>Donge Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>







  
<ul>
  
  <li>
    <a href="https://blog.csdn.net/dong__ge"  target="_blank" rel="noopener">
        CSDN
      </a>
  </li>
  
  <li>
    <a href="https://www.zhihu.com/people/Embedded_Art"  target="_blank" rel="noopener">
        知乎
      </a>
  </li>
  
  <li>
    <a href="https://github.com/UNIONDONG"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="/about/index_zh/"  >
        About
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>嵌入式</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3ebd3b438738bd5ab63f55999004f0e7" class="toggle"  />
    <label for="section-3ebd3b438738bd5ab63f55999004f0e7" class="flex justify-between">
      <a role="button" class="">嵌入式工程师养成记</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/self_improve/10w&#43;%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/" class="">【10W&#43;阅读】耗时一周总结的嵌入式学习路线，超详细</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-979254fc07de711332325335a96d33d1" class="toggle"  />
    <label for="section-979254fc07de711332325335a96d33d1" class="flex justify-between">
      <a role="button" class="">嵌入式面经</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/" class="">Soc的Bring Up流程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/" class="">CPU体系架构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="">Linux用户态和内核态交互的几种方式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Uboot开发</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/" class="">一、uboot基础了解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="">二、uboot启动流程分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E4%B8%89uboot%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/" class="">三、Uboot驱动模型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/uboot/%E5%9B%9Buboot%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" class="">四、Uboot命令行模式分析</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Linux开发</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-00ea238a2f9544b32c1424d14ac8d5b7" class="toggle"  />
    <label for="section-00ea238a2f9544b32c1424d14ac8d5b7" class="flex justify-between">
      <a role="button" class="">Linux 驱动开发基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="">【一文秒懂】Linux字符设备驱动</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/" class="">【一文秒懂】Linux设备树详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88linux%E5%86%85%E6%A0%B8%E4%B8%AD%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8typedef/" class="">【一文秒懂】为什么Linux内核中不经常使用typedef</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3eeeb8a1a5c1ce449ec7070209d774d9" class="toggle"  />
    <label for="section-3eeeb8a1a5c1ce449ec7070209d774d9" class="flex justify-between">
      <a role="button" class="">Linux API 揭秘</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/" class="">【Linux API 揭秘】module_init与module_exit</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" class="">【Linux API 揭秘】container_of函数详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-cad08b32e77ccfb31b07972873519838" class="toggle"  />
    <label for="section-cad08b32e77ccfb31b07972873519838" class="flex justify-between">
      <a role="button" class="">Linux 调试工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7devmem/" class="">【一文秒懂】Linux内核调试工具——devmem</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82ftrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/" class="">【一文秒懂】Ftrace系统调试工具使用终极指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="">【一文秒懂】TOP命令详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7debugfs/" class="">【一文秒懂】Linux内核调试工具——Debugfs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7iperf/" class="">【一文秒懂】Linux网络性能测试工具——Iperf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7gdb%E4%BB%8B%E7%BB%8D/" class="">【一文秒懂】Linux调试工具——GDB介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7gdbserver/" class="">【一文秒懂】Linux远程调试工具——gdbserver</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/" class="">【一文秒懂】Linux内核死锁检测</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90core-dump%E6%96%87%E4%BB%B6/" class="">【一文秒懂】如何生成core Dump文件</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E4%B9%8Bcore-dump%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">【一文秒懂】Linux之Core Dump文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E6%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/" class="">【一文秒懂】Linux内核态内存泄露检测工具</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b3bfa0c2506d9fd89a39b0698e122f31" class="toggle"  />
    <label for="section-b3bfa0c2506d9fd89a39b0698e122f31" class="flex justify-between">
      <a role="button" class="">Linux 内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/" class="">一、内存管理的由来及思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/" class="">二、虚拟地址空间布局</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/" class="">三、虚拟地址空间管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/" class="">四、物理地址空间设计模型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/" class="">五、物理内存空间布局及管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" class="">六、物理内存分配——伙伴系统</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2455edf5b3ea22c6053a61d28029cb9a" class="toggle"  />
    <label for="section-2455edf5b3ea22c6053a61d28029cb9a" class="flex justify-between">
      <a role="button" class="">Linux 内核锁详解</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%80%E5%86%85%E6%A0%B8%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5/" class="">【深入理解Linux锁机制】一、内核锁的由来</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%8C%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD/" class="">【深入理解Linux锁机制】二、中断屏蔽</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="">【深入理解Linux锁机制】三、原子操作</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%9B%9B%E8%87%AA%E6%97%8B%E9%94%81/" class="">【深入理解Linux锁机制】四、自旋锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%94%E8%A1%8D%E7%94%9F%E8%87%AA%E6%97%8B%E9%94%81/" class="">【深入理解Linux锁机制】五、衍生自旋锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AD%E4%BF%A1%E5%8F%B7%E9%87%8F/" class="">【深入理解Linux锁机制】六、信号量</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%83%E4%BA%92%E6%96%A5%E4%BD%93/" class="">【深入理解Linux锁机制】七、互斥体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E5%AE%8C%E6%88%90%E9%87%8F/" class="">【深入理解Linux锁机制】八、完成量</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3e346f9c1e7b71569b8cd088121d9787" class="toggle"  />
    <label for="section-3e346f9c1e7b71569b8cd088121d9787" class="flex justify-between">
      <a role="button" class="">Linux NVMEM 子系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%80efuse%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8%E6%B5%85%E6%9E%90/" class="">【NVMEM子系统深入剖析】一、Efuse介绍及安全启动浅析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%BA%8Cnvmem%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/" class="">【NVMEM子系统深入剖析】二、NVMEM驱动框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%89%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%9C%A8%E5%85%B3%E8%81%94/" class="">【NVMEM子系统深入剖析】三、核心数据结构及内在关联</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9Befuse%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/" class="">【NVMEM子系统深入剖析】四、efuse驱动实现流程</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9ae83851c5fe25a6d227e96b400b1ab9" class="toggle" checked />
    <label for="section-9ae83851c5fe25a6d227e96b400b1ab9" class="flex justify-between">
      <a role="button" class="">Linux LED子系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%80linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%89%8B%E5%BF%85%E8%AF%BB/" class="">【LED子系统深度剖析】一、开篇词|Linux驱动开发新手必读</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%8Cled%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/" class="">【LED子系统深度剖析】二、LED子系统框架分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%89%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="">【LED子系统深度剖析】三、硬件驱动层详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%9B%9B%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%80/" class="active">【LED子系统深度剖析】四、核心层详解（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%94%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%BA%8C/" class="">【LED子系统深度剖析】五、核心层详解（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AD%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%89/" class="">【LED子系统深度剖析】六、核心层详解（三）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%83%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AE%9E%E7%8E%B0/" class="">【LED子系统深度剖析】七、触发器实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AB%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/" class="">【LED子系统深度剖析】八、小试牛刀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B9%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E7%95%AA%E5%A4%96%E7%AF%87/" class="">【LED子系统深度剖析】九、数据结构详解（番外篇）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%8D%81%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/" class="">【LED子系统深度剖析】十、详细实现流程（番外篇）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-bf0229851221605a75715f5f9633256a" class="toggle"  />
    <label for="section-bf0229851221605a75715f5f9633256a" class="flex justify-between">
      <a role="button" class="">Linux MMC 子系统</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%80mmc_sd_sdio%E4%BB%8B%E7%BB%8D/" class="">【MMC子系统】一、MMC_SD_SDIO介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%8Cemmc%E5%8D%8F%E8%AE%AE/" class="">【MMC子系统】二、EMMC协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%89mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/" class="">【MMC子系统】三、MMC子系统框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%9B%9Bmmc%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%B1%82/" class="">【MMC子系统】四、MMC控制器驱动层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%94mmc%E6%A0%B8%E5%BF%83%E5%B1%82/" class="">【MMC子系统】五、MMC核心层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%ADmmc%E5%9D%97%E8%AE%BE%E5%A4%87%E5%B1%82/" class="">【MMC子系统】六、MMC块设备层</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-541874a152001b263009202c99a285c4" class="toggle"  />
    <label for="section-541874a152001b263009202c99a285c4" class="flex justify-between">
      <a role="button" class="">Bluetooth蓝牙开发详解</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%80%E6%89%93%E9%80%A0%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84bluetooth%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" class="">【Bluetooth蓝牙开发】一、打造全网最详细的Bluetooth开发教程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%8C%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/" class="">【Bluetooth蓝牙开发】二、蓝牙开发入门</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%89%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%80%BB%E8%A7%88%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE/" class="">【Bluetooth蓝牙开发】三、一篇文章，带你总览蓝牙协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%9B%9Bble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%E6%B5%85%E6%9E%90/" class="">【Bluetooth蓝牙开发】四、BLE协议之物理层浅析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%94ble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/" class="">【Bluetooth蓝牙开发】五、BLE协议之链路层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ADble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/" class="">【Bluetooth蓝牙开发】六、BLE协议之传输层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%83ble%E5%8D%8F%E8%AE%AE%E4%B9%8Bl2cap/" class="">【Bluetooth蓝牙开发】七、BLE协议之L2CAP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ABble%E5%8D%8F%E8%AE%AE%E4%B9%8Batt/" class="">【Bluetooth蓝牙开发】八、BLE协议之ATT</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B9%9Dble%E5%8D%8F%E8%AE%AEgatt/" class="">【Bluetooth蓝牙开发】九、BLE协议——GATT</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81ble%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%B9%BF%E6%92%AD%E6%89%AB%E6%8F%8F%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/" class="">【Bluetooth蓝牙开发】十、BLE蓝牙通信流程（建立连接，广播，扫描，断开连接）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%B8%80%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84bluez%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="">【Bluetooth蓝牙开发】十一、超详细的Bluez交叉编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%BA%8C%E8%93%9D%E7%89%99%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%E6%B1%87%E6%80%BB/" class="">【Bluetooth蓝牙开发】十二、蓝牙调试工具【集合汇总】</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3962d06d522e4ac6aca7d70bdb913d71" class="toggle"  />
    <label for="section-3962d06d522e4ac6aca7d70bdb913d71" class="flex justify-between">
      <a role="button" class="">WiFi开发详解</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/wifi/wifi%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="">WIFI基础知识汇总</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/wifi/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" class="">一文详解路由器配置信息</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/linux/wifi/wifi%E6%97%A0%E7%BC%9D%E6%BC%AB%E6%B8%B8%E8%AF%A6%E8%A7%A3/" class="">WiFi无缝漫游详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>【LED子系统深度剖析】四、核心层详解（一）</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#led子系统深度剖析四核心层详解一">【LED子系统深度剖析】四、核心层详解（一）</a>
      <ul>
        <li><a href="#1前言">1、前言</a></li>
        <li><a href="#2leds_init分析">2、leds_init分析</a>
          <ul>
            <li><a href="#21-相关数据结构">2.1 相关数据结构</a></li>
            <li><a href="#22-实现流程">2.2 实现流程</a></li>
          </ul>
        </li>
        <li><a href="#3leds_class_dev_pm_ops分析">3、leds_class_dev_pm_ops分析</a>
          <ul>
            <li><a href="#31-相关数据结构">3.1 相关数据结构</a></li>
            <li><a href="#32-相关实现">3.2 相关实现</a></li>
          </ul>
        </li>
        <li><a href="#4led_groups分析">4、led_groups分析</a>
          <ul>
            <li><a href="#41-相关数据结构">4.1 相关数据结构</a></li>
            <li><a href="#42-相关实现">4.2 相关实现</a></li>
            <li><a href="#43-扩展">4.3 扩展</a></li>
          </ul>
        </li>
        <li><a href="#5led-class的注册注销分析">5、led class的注册注销分析</a>
          <ul>
            <li><a href="#51-相关实现">5.1 相关实现</a></li>
          </ul>
        </li>
        <li><a href="#6总结">6、总结</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="led子系统深度剖析四核心层详解一">
  【LED子系统深度剖析】四、核心层详解（一）
  <a class="anchor" href="#led%e5%ad%90%e7%b3%bb%e7%bb%9f%e6%b7%b1%e5%ba%a6%e5%89%96%e6%9e%90%e5%9b%9b%e6%a0%b8%e5%bf%83%e5%b1%82%e8%af%a6%e8%a7%a3%e4%b8%80">#</a>
</h1>
<h2 id="1前言">
  1、前言
  <a class="anchor" href="#1%e5%89%8d%e8%a8%80">#</a>
</h2>
<blockquote>
<p>上篇文章我们了解了子系统的硬件驱动层，下面我们来分析驱动框架中核心层的实现以及作用。</p>
</blockquote>
<p><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/image-20230417084033734.png" alt="image-20230417084033734" /></p>
<p>在<code>LED</code>子系统框架中，核心层包括几个部分：核心层的实现部分（<code>led-core.c</code>）、<code>sysfs</code>文件节点创建（<code>led-class.c</code>）、触发功能实现(<code>led-triggers.c</code>、<code>driver/leds/triggers/led-xxx.c</code>)</p>
<blockquote>
<p>其中，触发功能部分较为独立，我们暂且先不去分析。</p>
</blockquote>
<p><span style="color: red;"><strong>我们先从<code>led-class.c</code>文件开始分析</strong></span></p>
<h2 id="2leds_init分析">
  2、leds_init分析
  <a class="anchor" href="#2leds_init%e5%88%86%e6%9e%90">#</a>
</h2>
<blockquote>
<p>该函数其主要是为了创建<code>LED</code>设备文件节点，方便用户通过节点直接访问。</p>
</blockquote>
<p>该文件，我们直接拉下底部，我们直接看入口函数：<code>leds_init</code></p>
<h3 id="21-相关数据结构">
  2.1 相关数据结构
  <a class="anchor" href="#21-%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h3>
<h4 id="211-class">
  2.1.1 class
  <a class="anchor" href="#211-class">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * struct class - device classes
</span><span style="color:#6272a4"> * @name:	Name of the class.
</span><span style="color:#6272a4"> * @owner:	The module owner.
</span><span style="color:#6272a4"> * @class_groups: Default attributes of this class.
</span><span style="color:#6272a4"> * @dev_groups:	Default attributes of the devices that belong to the class.
</span><span style="color:#6272a4"> * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.
</span><span style="color:#6272a4"> * @dev_uevent:	Called when a device is added, removed from this class, or a
</span><span style="color:#6272a4"> *		few other things that generate uevents to add the environment
</span><span style="color:#6272a4"> *		variables.
</span><span style="color:#6272a4"> * @devnode:	Callback to provide the devtmpfs.
</span><span style="color:#6272a4"> * @class_release: Called to release this class.
</span><span style="color:#6272a4"> * @dev_release: Called to release the device.
</span><span style="color:#6272a4"> * @shutdown_pre: Called at shut-down time before driver shutdown.
</span><span style="color:#6272a4"> * @ns_type:	Callbacks so sysfs can detemine namespaces.
</span><span style="color:#6272a4"> * @namespace:	Namespace of the device belongs to this class.
</span><span style="color:#6272a4"> * @get_ownership: Allows class to specify uid/gid of the sysfs directories
</span><span style="color:#6272a4"> *		for the devices belonging to the class. Usually tied to
</span><span style="color:#6272a4"> *		device&#39;s namespace.
</span><span style="color:#6272a4"> * @pm:		The default device power management operations of this class.
</span><span style="color:#6272a4"> * @p:		The private data of the driver core, no one other than the
</span><span style="color:#6272a4"> *		driver core can touch this.
</span><span style="color:#6272a4"> *
</span><span style="color:#6272a4"> * A class is a higher-level view of a device that abstracts out low-level
</span><span style="color:#6272a4"> * implementation details. Drivers may see a SCSI disk or an ATA disk, but,
</span><span style="color:#6272a4"> * at the class level, they are all simply disks. Classes allow user space
</span><span style="color:#6272a4"> * to work with devices based on what they do, rather than how they are
</span><span style="color:#6272a4"> * connected or how they work.
</span><span style="color:#6272a4"> */</span>
<span style="color:#ff79c6">struct</span> class {
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span>		<span style="color:#ff79c6">*</span>name;
    <span style="color:#ff79c6">struct</span> module		<span style="color:#ff79c6">*</span>owner;

    <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> attribute_group	<span style="color:#ff79c6">**</span>class_groups;
    <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> attribute_group	<span style="color:#ff79c6">**</span>dev_groups;
    <span style="color:#ff79c6">struct</span> kobject			<span style="color:#ff79c6">*</span>dev_kobj;

    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>dev_uevent)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev, <span style="color:#ff79c6">struct</span> kobj_uevent_env <span style="color:#ff79c6">*</span>env);
    <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>devnode)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev, umode_t <span style="color:#ff79c6">*</span>mode);

    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>class_release)(<span style="color:#ff79c6">struct</span> class <span style="color:#ff79c6">*</span>class);
    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>dev_release)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);

    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>shutdown_pre)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);

    <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> kobj_ns_type_operations <span style="color:#ff79c6">*</span>ns_type;
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>namespace)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);

    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>get_ownership)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev, kuid_t <span style="color:#ff79c6">*</span>uid, kgid_t <span style="color:#ff79c6">*</span>gid);

    <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> dev_pm_ops <span style="color:#ff79c6">*</span>pm;

    <span style="color:#ff79c6">struct</span> subsys_private <span style="color:#ff79c6">*</span>p;
};
</code></pre></div><p><strong>结构体名称</strong>：<code>class</code></p>
<p><strong>文件位置</strong>：<code>include/linux/device.h</code></p>
<p><strong>主要作用</strong>：设备类，表示某一类设备，在此是为了创建<code>led</code>设备类，源代码为：<code>static struct class *leds_class;</code></p>
<h3 id="22-实现流程">
  2.2 实现流程
  <a class="anchor" href="#22-%e5%ae%9e%e7%8e%b0%e6%b5%81%e7%a8%8b">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> __init <span style="color:#50fa7b">leds_init</span>(<span style="color:#8be9fd">void</span>)
{
    leds_class <span style="color:#ff79c6">=</span> class_create(THIS_MODULE, <span style="color:#f1fa8c">&#34;leds&#34;</span>);			<span style="color:#6272a4">//	创建leds文件节点
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (IS_ERR(leds_class))
        <span style="color:#ff79c6">return</span> PTR_ERR(leds_class);
    leds_class<span style="color:#ff79c6">-&gt;</span>pm <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>leds_class_dev_pm_ops;
    leds_class<span style="color:#ff79c6">-&gt;</span>dev_groups <span style="color:#ff79c6">=</span> led_groups;					
    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
}

<span style="color:#ff79c6">static</span> <span style="color:#8be9fd">void</span> __exit <span style="color:#50fa7b">leds_exit</span>(<span style="color:#8be9fd">void</span>)
{
    class_destroy(leds_class);
}

subsys_initcall(leds_init);
module_exit(leds_exit);

MODULE_AUTHOR(<span style="color:#f1fa8c">&#34;John Lenz, Richard Purdie&#34;</span>);
MODULE_LICENSE(<span style="color:#f1fa8c">&#34;GPL&#34;</span>);
MODULE_DESCRIPTION(<span style="color:#f1fa8c">&#34;LED Class Interface&#34;</span>);
</code></pre></div><p><strong>函数介绍</strong>：<code>leds_init</code>该函数在内核在加载的时候执行，调用<code>class_create</code>创建<code>LED</code>设备类，用于管理该类设备。</p>
<p><strong>实现思路</strong>：</p>
<ol>
<li>调用<code>class_create</code>创建<code>led</code>类设备</li>
<li>赋值结构体<code>leds_class-&gt;pm</code>，<code>leds_class_dev_pm_ops</code>配置电源管理接口，用于休眠唤醒,</li>
<li>赋值结构体<code>leds_class-&gt;dev_groups</code>，设置该类设备的文件属性。</li>
</ol>
<h2 id="3leds_class_dev_pm_ops分析">
  3、leds_class_dev_pm_ops分析
  <a class="anchor" href="#3leds_class_dev_pm_ops%e5%88%86%e6%9e%90">#</a>
</h2>
<blockquote>
<p>上面我们在创建<code>led</code>类的时候，赋值了<code>leds_class_dev_pm_ops</code>电源管理接口，那么该接口是怎么定义的呢？</p>
</blockquote>
<h3 id="31-相关数据结构">
  3.1 相关数据结构
  <a class="anchor" href="#31-%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h3>
<h4 id="311-dev_pm_ops">
  3.1.1 dev_pm_ops
  <a class="anchor" href="#311-dev_pm_ops">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">struct</span> dev_pm_ops {
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>prepare)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>complete)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>suspend)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>resume)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>freeze)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>thaw)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>poweroff)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>restore)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>suspend_late)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>resume_early)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>freeze_late)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>thaw_early)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>poweroff_late)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>restore_early)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>suspend_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>resume_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>freeze_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>thaw_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>poweroff_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>restore_noirq)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>runtime_suspend)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>runtime_resume)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>runtime_idle)(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev);
};
</code></pre></div><p><strong>结构体名称</strong>：<code>dev_pm_ops</code></p>
<p><strong>文件位置</strong>：<code>include/linux/pm.h</code></p>
<p><strong>主要作用</strong>：主要定义了设备电源管理的回调函数接口，我们一般使用<code>suspend</code>和<code>resume</code>两个，用于休眠，唤醒。</p>
<h3 id="32-相关实现">
  3.2 相关实现
  <a class="anchor" href="#32-%e7%9b%b8%e5%85%b3%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * led_classdev_suspend - suspend an led_classdev.
</span><span style="color:#6272a4"> * @led_cdev: the led_classdev to suspend.
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">led_classdev_suspend</span>(<span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev)
{
    led_cdev<span style="color:#ff79c6">-&gt;</span>flags <span style="color:#ff79c6">|=</span> LED_SUSPENDED;
    led_set_brightness_nopm(led_cdev, <span style="color:#bd93f9">0</span>);						<span style="color:#6272a4">//	灯灭
</span><span style="color:#6272a4"></span>}
EXPORT_SYMBOL_GPL(led_classdev_suspend);

<span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * led_classdev_resume - resume an led_classdev.
</span><span style="color:#6272a4"> * @led_cdev: the led_classdev to resume.
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">led_classdev_resume</span>(<span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev)
{
    led_set_brightness_nopm(led_cdev, led_cdev<span style="color:#ff79c6">-&gt;</span>brightness);	<span style="color:#6272a4">//	灯亮
</span><span style="color:#6272a4"></span>
    <span style="color:#ff79c6">if</span> (led_cdev<span style="color:#ff79c6">-&gt;</span>flash_resume)
        led_cdev<span style="color:#ff79c6">-&gt;</span>flash_resume(led_cdev);

    led_cdev<span style="color:#ff79c6">-&gt;</span>flags <span style="color:#ff79c6">&amp;=</span> <span style="color:#ff79c6">~</span>LED_SUSPENDED;
}
EXPORT_SYMBOL_GPL(led_classdev_resume);

<span style="color:#ff79c6">#ifdef CONFIG_PM_SLEEP
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">led_suspend</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);

    <span style="color:#ff79c6">if</span> (led_cdev<span style="color:#ff79c6">-&gt;</span>flags <span style="color:#ff79c6">&amp;</span> LED_CORE_SUSPENDRESUME)
        led_classdev_suspend(led_cdev);

    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
}

<span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">led_resume</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);

    <span style="color:#ff79c6">if</span> (led_cdev<span style="color:#ff79c6">-&gt;</span>flags <span style="color:#ff79c6">&amp;</span> LED_CORE_SUSPENDRESUME)
        led_classdev_resume(led_cdev);

    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
}
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>
<span style="color:#ff79c6">static</span> <span style="color:#50fa7b">SIMPLE_DEV_PM_OPS</span>(leds_class_dev_pm_ops, led_suspend, led_resume);

<span style="color:#6272a4">/*
</span><span style="color:#6272a4"> * Use this if you want to use the same suspend and resume callbacks for suspend
</span><span style="color:#6272a4"> * to RAM and hibernation.
</span><span style="color:#6272a4"> */</span>
<span style="color:#ff79c6">#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
</span><span style="color:#ff79c6">const struct dev_pm_ops name = { \
</span><span style="color:#ff79c6">    SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
</span><span style="color:#ff79c6">}
</span></code></pre></div><p><strong>函数介绍</strong>：代码的这一部分，主要用于实现休眠唤醒功能，然后将相关函数赋值给<code>dev_pm_ops</code>结构体中的回调函数</p>
<p><strong>实现思路</strong>：</p>
<ol>
<li>定义了几个函数<code>led_suspend</code>、<code>led_resume</code>、<code>led_classdev_resume</code>、<code>led_classdev_suspend</code>作为休眠唤醒的实现</li>
<li>通过宏定义<code>SIMPLE_DEV_PM_OPS</code>将函数绑定到<code>leds_class-&gt;pm</code>中，作为该类设备的休眠唤醒管理。</li>
</ol>
<blockquote>
<p>这里<code>SIMPLE_DEV_PM_OPS</code>宏定义较为简单，自行翻阅源码查看即可！</p>
</blockquote>
<h2 id="4led_groups分析">
  4、led_groups分析
  <a class="anchor" href="#4led_groups%e5%88%86%e6%9e%90">#</a>
</h2>
<blockquote>
<p>上面我们在创建<code>led</code>类的时候，将<code>led_groups</code>赋值给了<code>struct attribute_group</code>属性组结构体，那么<code>led_groups</code>是怎么定义的呢？</p>
</blockquote>
<h3 id="41-相关数据结构">
  4.1 相关数据结构
  <a class="anchor" href="#41-%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h3>
<h4 id="411-attribute_group">
  4.1.1 attribute_group
  <a class="anchor" href="#411-attribute_group">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * struct attribute_group - data structure used to declare an attribute group.
</span><span style="color:#6272a4"> * @name:	Optional: Attribute group name
</span><span style="color:#6272a4"> *		If specified, the attribute group will be created in
</span><span style="color:#6272a4"> *		a new subdirectory with this name.
</span><span style="color:#6272a4"> * @is_visible:	Optional: Function to return permissions associated with an
</span><span style="color:#6272a4"> *		attribute of the group. Will be called repeatedly for each
</span><span style="color:#6272a4"> *		non-binary attribute in the group. Only read/write
</span><span style="color:#6272a4"> *		permissions as well as SYSFS_PREALLOC are accepted. Must
</span><span style="color:#6272a4"> *		return 0 if an attribute is not visible. The returned value
</span><span style="color:#6272a4"> *		will replace static permissions defined in struct attribute.
</span><span style="color:#6272a4"> * @is_bin_visible:
</span><span style="color:#6272a4"> *		Optional: Function to return permissions associated with a
</span><span style="color:#6272a4"> *		binary attribute of the group. Will be called repeatedly
</span><span style="color:#6272a4"> *		for each binary attribute in the group. Only read/write
</span><span style="color:#6272a4"> *		permissions as well as SYSFS_PREALLOC are accepted. Must
</span><span style="color:#6272a4"> *		return 0 if a binary attribute is not visible. The returned
</span><span style="color:#6272a4"> *		value will replace static permissions defined in
</span><span style="color:#6272a4"> *		struct bin_attribute.
</span><span style="color:#6272a4"> * @attrs:	Pointer to NULL terminated list of attributes.
</span><span style="color:#6272a4"> * @bin_attrs:	Pointer to NULL terminated list of binary attributes.
</span><span style="color:#6272a4"> *		Either attrs or bin_attrs or both must be provided.
</span><span style="color:#6272a4"> */</span>
<span style="color:#ff79c6">struct</span> attribute_group {
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span>		<span style="color:#ff79c6">*</span>name;
    umode_t			(<span style="color:#ff79c6">*</span>is_visible)(<span style="color:#ff79c6">struct</span> kobject <span style="color:#ff79c6">*</span>,
                          <span style="color:#ff79c6">struct</span> attribute <span style="color:#ff79c6">*</span>, <span style="color:#8be9fd">int</span>);
    umode_t			(<span style="color:#ff79c6">*</span>is_bin_visible)(<span style="color:#ff79c6">struct</span> kobject <span style="color:#ff79c6">*</span>,
                          <span style="color:#ff79c6">struct</span> bin_attribute <span style="color:#ff79c6">*</span>, <span style="color:#8be9fd">int</span>);
    <span style="color:#ff79c6">struct</span> attribute	<span style="color:#ff79c6">**</span>attrs;
    <span style="color:#ff79c6">struct</span> bin_attribute	<span style="color:#ff79c6">**</span>bin_attrs;
};
</code></pre></div><p><strong>结构体名称</strong>：<code>attribute_group</code></p>
<p><strong>文件位置</strong>：<code>include/linux/sysfs.h</code></p>
<p><strong>主要作用</strong>：定义一个属性组，其中包括一组属性和二进制属性，这些属性可以与内核对象相关联，以便用户的访问。</p>
<h4 id="412-attribute">
  4.1.2 attribute
  <a class="anchor" href="#412-attribute">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">struct</span> attribute {
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span>		<span style="color:#ff79c6">*</span>name;
    umode_t			mode;
<span style="color:#ff79c6">#ifdef CONFIG_DEBUG_LOCK_ALLOC
</span><span style="color:#ff79c6"></span>    <span style="color:#8be9fd">bool</span>			<span style="color:#8be9fd;font-style:italic">ignore_lockdep</span>:<span style="color:#bd93f9">1</span>;
    <span style="color:#ff79c6">struct</span> lock_class_key	<span style="color:#ff79c6">*</span>key;
    <span style="color:#ff79c6">struct</span> lock_class_key	skey;
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>};
</code></pre></div><p><strong>结构体名称</strong>：<code>attribute</code></p>
<p><strong>文件位置</strong>：<code>include/linux/sysfs.h</code></p>
<p><strong>主要作用</strong>：代表一个属性</p>
<h3 id="42-相关实现">
  4.2 相关实现
  <a class="anchor" href="#42-%e7%9b%b8%e5%85%b3%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">static</span> ssize_t <span style="color:#50fa7b">brightness_show</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev,
        <span style="color:#ff79c6">struct</span> device_attribute <span style="color:#ff79c6">*</span>attr, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);

    <span style="color:#6272a4">/* no lock needed for this */</span>
    led_update_brightness(led_cdev);

    <span style="color:#ff79c6">return</span> sprintf(buf, <span style="color:#f1fa8c">&#34;%u</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, led_cdev<span style="color:#ff79c6">-&gt;</span>brightness);
}

<span style="color:#ff79c6">static</span> ssize_t <span style="color:#50fa7b">brightness_store</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev,
        <span style="color:#ff79c6">struct</span> device_attribute <span style="color:#ff79c6">*</span>attr, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf, size_t size)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);
    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> state;
    ssize_t ret;

    mutex_lock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);

    <span style="color:#ff79c6">if</span> (led_sysfs_is_disabled(led_cdev)) {
        ret <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>EBUSY;
        <span style="color:#ff79c6">goto</span> unlock;
    }

    ret <span style="color:#ff79c6">=</span> kstrtoul(buf, <span style="color:#bd93f9">10</span>, <span style="color:#ff79c6">&amp;</span>state);
    <span style="color:#ff79c6">if</span> (ret)
        <span style="color:#ff79c6">goto</span> unlock;

    <span style="color:#ff79c6">if</span> (state <span style="color:#ff79c6">==</span> LED_OFF)
        led_trigger_remove(led_cdev);
    led_set_brightness(led_cdev, state);

    ret <span style="color:#ff79c6">=</span> size;
<span style="color:#8be9fd;font-style:italic">unlock</span>:
    mutex_unlock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
    <span style="color:#ff79c6">return</span> ret;
}
<span style="color:#ff79c6">static</span> <span style="color:#50fa7b">DEVICE_ATTR_RW</span>(brightness);

<span style="color:#ff79c6">static</span> ssize_t <span style="color:#50fa7b">max_brightness_show</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev,
        <span style="color:#ff79c6">struct</span> device_attribute <span style="color:#ff79c6">*</span>attr, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);

    <span style="color:#ff79c6">return</span> sprintf(buf, <span style="color:#f1fa8c">&#34;%u</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, led_cdev<span style="color:#ff79c6">-&gt;</span>max_brightness);
}
<span style="color:#ff79c6">static</span> <span style="color:#50fa7b">DEVICE_ATTR_RO</span>(max_brightness);

<span style="color:#ff79c6">#ifdef CONFIG_LEDS_TRIGGERS
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">static</span> <span style="color:#50fa7b">DEVICE_ATTR</span>(trigger, <span style="color:#bd93f9">0644</span>, led_trigger_show, led_trigger_store);

<span style="color:#6272a4">//	属性文件
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">struct</span> attribute <span style="color:#ff79c6">*</span>led_trigger_attrs[] <span style="color:#ff79c6">=</span> {
    <span style="color:#ff79c6">&amp;</span>dev_attr_trigger.attr,
    <span style="color:#8be9fd;font-style:italic">NULL</span>,
};
<span style="color:#ff79c6">static</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> attribute_group led_trigger_group <span style="color:#ff79c6">=</span> {
    .attrs <span style="color:#ff79c6">=</span> led_trigger_attrs,
};
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">//	属性文件
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">struct</span> attribute <span style="color:#ff79c6">*</span>led_class_attrs[] <span style="color:#ff79c6">=</span> {
    <span style="color:#ff79c6">&amp;</span>dev_attr_brightness.attr,
    <span style="color:#ff79c6">&amp;</span>dev_attr_max_brightness.attr,
    <span style="color:#8be9fd;font-style:italic">NULL</span>,
};

<span style="color:#ff79c6">static</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> attribute_group led_group <span style="color:#ff79c6">=</span> {
    .attrs <span style="color:#ff79c6">=</span> led_class_attrs,
};

<span style="color:#ff79c6">static</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> attribute_group <span style="color:#ff79c6">*</span>led_groups[] <span style="color:#ff79c6">=</span> {
    <span style="color:#ff79c6">&amp;</span>led_group,
<span style="color:#ff79c6">#ifdef CONFIG_LEDS_TRIGGERS
</span><span style="color:#ff79c6"></span>    <span style="color:#ff79c6">&amp;</span>led_trigger_group,
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>    <span style="color:#8be9fd;font-style:italic">NULL</span>,
};
</code></pre></div><p><strong>代码介绍</strong>：该部分代码主要用于创建<code>LED</code>属性组，并且负责实现用户空间操作的接口。</p>
<p><strong>实现思路</strong>：</p>
<ol>
<li>定义一个<code>led_groups</code>属性组的二维数组，管理该类设备的所有属性</li>
<li>这个<code>led_groups</code>二维数组，其中又包括两个属性组：<code>led_group</code>、和<code>led_trigger_group</code>，一个用于<code>LED</code>亮度控制，一个用于触发控制。</li>
<li><code>led_group</code>属性组中又包括多个属性，如：<code>dev_attr_brightness.attr</code>、<code>dev_attr_max_brightness.attr</code>，分别表示<code>LED</code>亮度和最大亮度的设置。</li>
<li><code>led_trigger_group</code>属性组包括一个属性，如：<code>dev_attr_trigger.attr</code>，用于控制触发属性</li>
<li>定义完属性后，需要提供操作属性的接口，就是上面的<code>led_trigger_show</code>、<code>led_trigger_store</code>、<code>max_brightness_show</code>、<code>brightness_show</code>、<code>brightness_store</code>，其中<code>xxx_show</code>表示读属性，<code>xxx_store</code>表示写属性</li>
<li>至此，所有的属性定义完毕，并且将其读写属性的接口与该属性进行了绑定</li>
<li>最后，通过在<code>leds_init</code>接口中，调用<code>leds_class-&gt;dev_groups = led_groups;</code>，将属性组注册到<code>LED</code>类中进行管理。</li>
</ol>
<blockquote>
<p><span style="color: red;"><strong>阅读代码时，从下网上看，更容易理解！</strong></span></p>
</blockquote>
<h3 id="43-扩展">
  4.3 扩展
  <a class="anchor" href="#43-%e6%89%a9%e5%b1%95">#</a>
</h3>
<blockquote>
<p>可能代码中有些地方对于初学者不太容易理解，如：为什么没有找到<code>brightness_store</code>和<code>brightness_show</code>与属性绑定的地方？为什么函数要定义成这个名字？</p>
</blockquote>
<p>解答这个问题，也是涉及到了<code>Linux</code>内核的设计模式，其中充斥着大量的宏定义，主要用作字符串的拼接，最终生成想要的定义！</p>
<h4 id="431-device_attr_rw分析">
  4.3.1 DEVICE_ATTR_RW分析
  <a class="anchor" href="#431-device_attr_rw%e5%88%86%e6%9e%90">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">static</span> ssize_t <span style="color:#50fa7b">brightness_show</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev,
        <span style="color:#ff79c6">struct</span> device_attribute <span style="color:#ff79c6">*</span>attr, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);

    <span style="color:#6272a4">/* no lock needed for this */</span>
    led_update_brightness(led_cdev);

    <span style="color:#ff79c6">return</span> sprintf(buf, <span style="color:#f1fa8c">&#34;%u</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, led_cdev<span style="color:#ff79c6">-&gt;</span>brightness);
}

<span style="color:#ff79c6">static</span> ssize_t <span style="color:#50fa7b">brightness_store</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev,
        <span style="color:#ff79c6">struct</span> device_attribute <span style="color:#ff79c6">*</span>attr, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf, size_t size)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev <span style="color:#ff79c6">=</span> dev_get_drvdata(dev);
    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> state;
    ssize_t ret;

    mutex_lock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);

    <span style="color:#ff79c6">if</span> (led_sysfs_is_disabled(led_cdev)) {
        ret <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>EBUSY;
        <span style="color:#ff79c6">goto</span> unlock;
    }

    ret <span style="color:#ff79c6">=</span> kstrtoul(buf, <span style="color:#bd93f9">10</span>, <span style="color:#ff79c6">&amp;</span>state);
    <span style="color:#ff79c6">if</span> (ret)
        <span style="color:#ff79c6">goto</span> unlock;

    <span style="color:#ff79c6">if</span> (state <span style="color:#ff79c6">==</span> LED_OFF)
        led_trigger_remove(led_cdev);
    led_set_brightness(led_cdev, state);

    ret <span style="color:#ff79c6">=</span> size;
<span style="color:#8be9fd;font-style:italic">unlock</span>:
    mutex_unlock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
    <span style="color:#ff79c6">return</span> ret;
}
<span style="color:#ff79c6">static</span> <span style="color:#50fa7b">DEVICE_ATTR_RW</span>(brightness);
</code></pre></div><p><strong>代码介绍</strong>：上面定义了两个函数（<code>brightness_show</code>，<code>brightness_store</code>）和一个属性名称（<code>brightness</code>），并且通过<code>DEVICE_ATTR_RW</code>宏定义将属性和函数关联起来。</p>
<p><strong>实现思路</strong>：</p>
<blockquote>
<p>我们分析一下<code>DEVICE_ATTR_RW</code>的宏定义</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">//	static DEVICE_ATTR_RW(brightness);
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">#define DEVICE_ATTR_RW(_name) \
</span><span style="color:#ff79c6">    struct device_attribute dev_attr_##_name = __ATTR_RW(_name)
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">//	static struct device_attribute dev_attr_brightness = __ATTR_RW(brightness)
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">#define __ATTR_RW(_name) __ATTR(_name, 0644, _name##_show, _name##_store)
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">//	static struct device_attribute dev_attr_brightness = __ATTR(brightness, 0644, brightness_show, brightness_store)
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">#define __ATTR(_name, _mode, _show, _store) {				\
</span><span style="color:#ff79c6">    .attr = {.name = __stringify(_name),				\
</span><span style="color:#ff79c6">         .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\
</span><span style="color:#ff79c6">    .show	= _show,						\
</span><span style="color:#ff79c6">    .store	= _store,						\
</span><span style="color:#ff79c6">}
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">//	static struct device_attribute dev_attr_brightness = {
</span><span style="color:#6272a4">//	.attr = {
</span><span style="color:#6272a4">//		.name = __stringify(brightness),
</span><span style="color:#6272a4">//		.mode = VERIFY_OCTAL_PERMISSIONS(0644),
</span><span style="color:#6272a4">//	}
</span><span style="color:#6272a4">//	.show = brightness_show,
</span><span style="color:#6272a4">//	.store = brightness_store,
</span><span style="color:#6272a4">//}
</span></code></pre></div><p>上面屏蔽的内容就是<code>static DEVICE_ATTR_RW(brightness)</code>展开的原貌，这样就与上面的两个函数（<code>brightness_show</code>，<code>brightness_store</code>）关联了起来！</p>
<h2 id="5led-class的注册注销分析">
  5、led class的注册注销分析
  <a class="anchor" href="#5led-class%e7%9a%84%e6%b3%a8%e5%86%8c%e6%b3%a8%e9%94%80%e5%88%86%e6%9e%90">#</a>
</h2>
<blockquote>
<p>在<code>led-class.c</code>还剩下一部分代码，那就是负责提供注册，注销<code>led</code>设备的相关接口</p>
</blockquote>
<h3 id="51-相关实现">
  5.1 相关实现
  <a class="anchor" href="#51-%e7%9b%b8%e5%85%b3%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<h4 id="511-devm_of_led_classdev_register">
  5.1.1 devm_of_led_classdev_register
  <a class="anchor" href="#511-devm_of_led_classdev_register">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * devm_of_led_classdev_register - resource managed led_classdev_register()
</span><span style="color:#6272a4"> *
</span><span style="color:#6272a4"> * @parent: parent of LED device
</span><span style="color:#6272a4"> * @led_cdev: the led_classdev structure for this device.
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd">int</span> <span style="color:#50fa7b">devm_of_led_classdev_register</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>parent,
                  <span style="color:#ff79c6">struct</span> device_node <span style="color:#ff79c6">*</span>np,
                  <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev)
{
    <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">**</span>dr;
    <span style="color:#8be9fd">int</span> rc;

    dr <span style="color:#ff79c6">=</span> devres_alloc(devm_led_classdev_release, <span style="color:#ff79c6">sizeof</span>(<span style="color:#ff79c6">*</span>dr), GFP_KERNEL);
    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>dr)
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span>ENOMEM;

    rc <span style="color:#ff79c6">=</span> of_led_classdev_register(parent, np, led_cdev);		<span style="color:#6272a4">//	注册到子系统
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (rc) {
        devres_free(dr);
        <span style="color:#ff79c6">return</span> rc;
    }

    <span style="color:#ff79c6">*</span>dr <span style="color:#ff79c6">=</span> led_cdev;
    devres_add(parent, dr);

    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
}
EXPORT_SYMBOL_GPL(devm_of_led_classdev_register);
</code></pre></div><p><strong>函数介绍</strong>：<code>devm_of_led_classdev_register</code>是<code>of_led_classdev_register</code>函数的资源管理版本。即：在<code>of_led_classdev_register</code>之上，进行了资源的管理。</p>
<p><strong>实现思路</strong>：</p>
<ol>
<li>先通过<code>struct led_classdev **dr</code>创建一个新对象，并将其与给定的设备节点关联</li>
<li>该函数分配了一个<code>devres</code>结构来管理<code>led_classdev</code>对象的生命周期。</li>
<li>如果注册成功，则<code>led_classdev</code>对象将存储在<code>devres</code>结构中，并与父设备关联。</li>
</ol>
<h4 id="512-of_led_classdev_register">
  5.1.2 of_led_classdev_register
  <a class="anchor" href="#512-of_led_classdev_register">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * of_led_classdev_register - register a new object of led_classdev class.
</span><span style="color:#6272a4"> *
</span><span style="color:#6272a4"> * @parent: parent of LED device
</span><span style="color:#6272a4"> * @led_cdev: the led_classdev structure for this device.
</span><span style="color:#6272a4"> * @np: DT node describing this LED
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd">int</span> <span style="color:#50fa7b">of_led_classdev_register</span>(<span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>parent, <span style="color:#ff79c6">struct</span> device_node <span style="color:#ff79c6">*</span>np,
                <span style="color:#ff79c6">struct</span> led_classdev <span style="color:#ff79c6">*</span>led_cdev)
{
    <span style="color:#8be9fd">char</span> name[LED_MAX_NAME_SIZE];
    <span style="color:#8be9fd">int</span> ret;

    ret <span style="color:#ff79c6">=</span> led_classdev_next_name(led_cdev<span style="color:#ff79c6">-&gt;</span>name, name, <span style="color:#ff79c6">sizeof</span>(name));		<span style="color:#6272a4">//	生成唯一的节点名称
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (ret <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>)
        <span style="color:#ff79c6">return</span> ret;

    mutex_init(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
    mutex_lock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
    led_cdev<span style="color:#ff79c6">-&gt;</span>dev <span style="color:#ff79c6">=</span> device_create_with_groups(leds_class, parent, <span style="color:#bd93f9">0</span>,
                led_cdev, led_cdev<span style="color:#ff79c6">-&gt;</span>groups, <span style="color:#f1fa8c">&#34;%s&#34;</span>, name);					<span style="color:#6272a4">//	关联属性文件
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (IS_ERR(led_cdev<span style="color:#ff79c6">-&gt;</span>dev)) {
        mutex_unlock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
        <span style="color:#ff79c6">return</span> PTR_ERR(led_cdev<span style="color:#ff79c6">-&gt;</span>dev);
    }
    led_cdev<span style="color:#ff79c6">-&gt;</span>dev<span style="color:#ff79c6">-&gt;</span>of_node <span style="color:#ff79c6">=</span> np;

    <span style="color:#ff79c6">if</span> (ret)
        dev_warn(parent, <span style="color:#f1fa8c">&#34;Led %s renamed to %s due to name collision&#34;</span>,
                led_cdev<span style="color:#ff79c6">-&gt;</span>name, dev_name(led_cdev<span style="color:#ff79c6">-&gt;</span>dev));

    <span style="color:#ff79c6">if</span> (led_cdev<span style="color:#ff79c6">-&gt;</span>flags <span style="color:#ff79c6">&amp;</span> LED_BRIGHT_HW_CHANGED) {
        ret <span style="color:#ff79c6">=</span> led_add_brightness_hw_changed(led_cdev);
        <span style="color:#ff79c6">if</span> (ret) {
            device_unregister(led_cdev<span style="color:#ff79c6">-&gt;</span>dev);
            mutex_unlock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);
            <span style="color:#ff79c6">return</span> ret;
        }
    }

    led_cdev<span style="color:#ff79c6">-&gt;</span>work_flags <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
<span style="color:#ff79c6">#ifdef CONFIG_LEDS_TRIGGERS
</span><span style="color:#ff79c6"></span>    init_rwsem(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>trigger_lock);
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6">#ifdef CONFIG_LEDS_BRIGHTNESS_HW_CHANGED
</span><span style="color:#ff79c6"></span>    led_cdev<span style="color:#ff79c6">-&gt;</span>brightness_hw_changed <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>    <span style="color:#6272a4">/* add to the list of leds */</span>
    down_write(<span style="color:#ff79c6">&amp;</span>leds_list_lock);
    list_add_tail(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>node, <span style="color:#ff79c6">&amp;</span>leds_list);
    up_write(<span style="color:#ff79c6">&amp;</span>leds_list_lock);

    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>led_cdev<span style="color:#ff79c6">-&gt;</span>max_brightness)
        led_cdev<span style="color:#ff79c6">-&gt;</span>max_brightness <span style="color:#ff79c6">=</span> LED_FULL;

    led_update_brightness(led_cdev);

    led_init_core(led_cdev);					<span style="color:#6272a4">//	核心层初始化
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">#ifdef CONFIG_LEDS_TRIGGERS
</span><span style="color:#ff79c6"></span>    led_trigger_set_default(led_cdev);
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>
    mutex_unlock(<span style="color:#ff79c6">&amp;</span>led_cdev<span style="color:#ff79c6">-&gt;</span>led_access);

    dev_dbg(parent, <span style="color:#f1fa8c">&#34;Registered led device: %s</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,
            led_cdev<span style="color:#ff79c6">-&gt;</span>name);

    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
}
</code></pre></div><p><strong>函数介绍</strong>：<code>of_led_classdev_register</code>注册一个新的<code>led_classdev</code>对象。</p>
<blockquote>
<p><code>led_classdev</code>该结构体在上一篇文章中有介绍到，我们在<code>led-gpio.c</code>中创建并初始化，随后我们会调用注册函数<code>devm_of_led_classdev_register</code>来将创建的<code>led_classdev</code>对象注册到<code>LED</code>子系统中，也就是该函数的作用。</p>
</blockquote>
<p><strong>实现思路</strong>：</p>
<ol>
<li>通过<code>led_classdev_next_name</code>来对<code>LED</code>名字添加序号，生成唯一名称</li>
<li>使用<code>device_create_with_groups</code>接口，将<code>led_classdev</code>对象与<code>leds_class</code>关联，创建一个新的设备</li>
<li>最后调用<code>led_init_core</code>接口，初始化了 <code>LED</code> 核心并为设备设置了默认触发器。</li>
</ol>
<blockquote>
<p><code>led_init_core</code>就是在<code>led-core.c</code>中实现的啦，我们下一篇文章分析。</p>
</blockquote>
<h4 id="513-led_classdev_next_name">
  5.1.3 led_classdev_next_name
  <a class="anchor" href="#513-led_classdev_next_name">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">led_classdev_next_name</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>init_name, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name,
                  size_t len)
{
    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
    <span style="color:#8be9fd">int</span> ret <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
    <span style="color:#ff79c6">struct</span> device <span style="color:#ff79c6">*</span>dev;

    strlcpy(name, init_name, len);

    <span style="color:#ff79c6">while</span> ((ret <span style="color:#ff79c6">&lt;</span> len) <span style="color:#ff79c6">&amp;&amp;</span>
           (dev <span style="color:#ff79c6">=</span> class_find_device(leds_class, <span style="color:#8be9fd;font-style:italic">NULL</span>, name, match_name))) {
        put_device(dev);
        ret <span style="color:#ff79c6">=</span> snprintf(name, len, <span style="color:#f1fa8c">&#34;%s_%u&#34;</span>, init_name, <span style="color:#ff79c6">++</span>i);
    }

    <span style="color:#ff79c6">if</span> (ret <span style="color:#ff79c6">&gt;=</span> len)
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span>ENOMEM;

    <span style="color:#ff79c6">return</span> i;
}
</code></pre></div><p><strong>函数介绍</strong>：<code>led_classdev_next_name</code>，该函数根据提供的初始名称，生成一个唯一的 LED 设备名称。它通过在初始名称后添加下划线和数字来实现。</p>
<p><strong>实现思路</strong>：</p>
<ol>
<li>调用<code>strlcpy</code>接口，将初始名称拷贝到<code>name</code> 缓冲区中</li>
<li>调用<code>class_find_device</code>去循环检查<code>leds_class</code> 类中是否已经存在一个具有当前 <code>name</code> 的设备。</li>
<li>如果存在，则将调用<code>snprintf</code>在 <code>init_name</code> 后面添加下划线和数字</li>
</ol>
<h2 id="6总结">
  6、总结
  <a class="anchor" href="#6%e6%80%bb%e7%bb%93">#</a>
</h2>
<p><code>led-class.c</code>该文件的详细分析如上文，我们回顾一下其主要作用：</p>
<ol>
<li>创建<code>leds_class</code>，并且初始化相关字段，如：<code>pm</code>电源管理，<code>dev_groups</code>设备属性</li>
<li>定义<code>suspend</code>、<code>resume</code>函数，用于<code>LED</code>类设备的休眠唤醒；定义多个属性组，多个属性，并且实现对应的函数，如：<code>brightness_show</code>、<code>brightness_store</code>等，并将其注册到<code>LED</code>类中，以便<code>LED</code>属性在用户空间的读写</li>
<li>提供注册注销函数：<code>devm_of_led_classdev_register</code>、<code>devm_led_classdev_unregister</code>，为了底层将创建的<code>led_classdev</code>与<code>leds_class</code>关联，注册进入子系统</li>
</ol>
<center><b> <font color ="blue">欢迎关注【嵌入式艺术】，董哥原创！</font></b></center>
<div align=center><img src="https://image-1305421143.cos.ap-nanjing.myqcloud.com/image/blog.png" alt="img" width = "60%" height ="10%"/>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){if(window.getSelection().toString())return;a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#led子系统深度剖析四核心层详解一">【LED子系统深度剖析】四、核心层详解（一）</a>
      <ul>
        <li><a href="#1前言">1、前言</a></li>
        <li><a href="#2leds_init分析">2、leds_init分析</a>
          <ul>
            <li><a href="#21-相关数据结构">2.1 相关数据结构</a></li>
            <li><a href="#22-实现流程">2.2 实现流程</a></li>
          </ul>
        </li>
        <li><a href="#3leds_class_dev_pm_ops分析">3、leds_class_dev_pm_ops分析</a>
          <ul>
            <li><a href="#31-相关数据结构">3.1 相关数据结构</a></li>
            <li><a href="#32-相关实现">3.2 相关实现</a></li>
          </ul>
        </li>
        <li><a href="#4led_groups分析">4、led_groups分析</a>
          <ul>
            <li><a href="#41-相关数据结构">4.1 相关数据结构</a></li>
            <li><a href="#42-相关实现">4.2 相关实现</a></li>
            <li><a href="#43-扩展">4.3 扩展</a></li>
          </ul>
        </li>
        <li><a href="#5led-class的注册注销分析">5、led class的注册注销分析</a>
          <ul>
            <li><a href="#51-相关实现">5.1 相关实现</a></li>
          </ul>
        </li>
        <li><a href="#6总结">6、总结</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












