<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Donge Blog</title>
    <link>https://uniondong.github.io/categories/tech/</link>
    <description>Recent content in Tech on Donge Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Jan 2024 21:45:04 +0800</lastBuildDate><atom:link href="https://uniondong.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【一文秒懂】Linux字符设备驱动</title>
      <link>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Fri, 19 Jan 2024 21:40:08 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid>
      <description>【一文秒懂】Linux字符设备驱动 #  1、前言 #  众所周知，Linux内核主要包括三种驱动模型，字符设备驱动，块设备驱动以及网络设备驱动。
其中，Linux字符设备驱动，可以说是Linux驱动开发中最常见的一种驱动模型。
我们该系列文章，主要为了帮助大家快速入门Linux驱动开发，该篇主要来了解一些字符设备驱动的框架和机制。
 系列文章基于Kernel 4.19
  2、关键数据结构 #  2.1 cdev #  struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count; } __randomize_layout; 结构体名称：cdev
文件位置：include/linux/cdev.h
主要作用：cdev可以理解为char device，用来抽象一个字符设备。
核心成员及含义：
 kobj：表示一个内核对象。 owner：指向该模块的指针 ops：指向文件操作的指针，包括open、read、write等操作接口 list：用于将该设备加入到内核模块链表中 dev：设备号，由主设备号和次设备号构成 count：表示有多少个同类型设备，也间接表示设备号的范围 __randomize_layout：一个编译器指令，用于随机化结构体的布局，以增加安全性。   2.2 file_operations #  struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU  unsigned (*mmap_capabilities)(struct file *); #endif  ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); int (*dedupe_file_range)(struct file *, loff_t, struct file *, loff_t, u64); int (*fadvise)(struct file *, loff_t, loff_t, int); } __randomize_layout; 结构体名称：file_operations</description>
    </item>
    
    <item>
      <title>【MMC子系统】一、MMC_SD_SDIO介绍</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%80mmc_sd_sdio%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 19 Jan 2024 21:16:36 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%80mmc_sd_sdio%E4%BB%8B%E7%BB%8D/</guid>
      <description>【MMC子系统】 一、MMC/SD/SDIO介绍 #  1、前言 #  该节学习Linux Kernel的MMC子系统，也称为块设备驱动，正如其名，与字符驱动相比，MMC子系统以块为单位进行操作。
同时，由于MMC Card、SD Card、SDIO Card等设备协议基本大同小异，所以在Linux Kernel中使用MMC子系统来统一管理！
 2、MMC/SD/SDIO介绍 #  上面我们了解到，Linux Kernel使用统一的子系统模型来管理MMC、SD、SDIO等设备，那么为什么要这样设计呢？
 答案当然是：三者协议有一定的共通性。
  MMC（MultiMediaCard）多媒体卡设备，从本质上看，它是一种用于固态非易失性存储的内存卡（memory card）规范，定义了诸如卡的形态、尺寸、容量、电气信号、和主机之间的通信协议等方方面面的内容。
1997年，MMC规范正式发布，至今已经进化出了SD、MicroSD、SDIO、EMMC等多种不同的规范，虽然眼花缭乱，但是追其根源，都源于MMC规范，所以Linux Kernel可以将其统一管理！
 MMC：强调的是多媒体存储（MM：MultiMedia）
SD：强调的是安全数据（SD：Secure Digital）
SDIO：强调的是IO接口(IO：Input/Output)
   更多干货可见：高级工程师聚集地，助力大家更上一层楼！
  3、总线接口 #  MMC、SD、SDIO其物理接口也十分相似，我们以MMC为例进行分析。
我们的MMC卡如上图所示，内部我们不展开分析，直接将其作为一个完整的设备来分析。
其通过CLK、CMD、DATA等管脚与我们的SOC通信，两者之间当然少不了Controller了。
把通信总线部分，拿出来看：
 CLK：提供SOC和设备之间的通信时钟，常用的通信频率为400KHz（识卡）、25MHz，50MHz
CMD：提供SOC和设备之间的通信命令，标识不同的命令编号，类型多达50多种。
DATA：提供SOC和设备之间的数据通信，其通信总线有8根，可自定义设置，一般默认的是1-bit (默认)模式、4-bit模式和8-bit模式。当然数据线越多，传输越快嘛，但是处理起来也稍微繁琐。
除了上面的一些管脚，当然还少不了VCC、GND等管脚喽，与其它外设不同的是，MMC类的设备，还会有一个检测引脚DET，用于检测是否存在卡设备（热插拔）。
  好啦，上面我们对MMC、SD、SDIO进行简单了解，也知道了通信的常用方式与物理接口，当然其最核心在于通信的协议啦！由于协议过于复杂，我们放到后面了解。
 4、参考文章 #  [1]：http://www.wowotech.net/basic_tech/mmc_sd_sdio_intro.html
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】一、打造全网最详细的Bluetooth开发教程</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%80%E6%89%93%E9%80%A0%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84bluetooth%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 19 Jan 2024 20:59:43 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%80%E6%89%93%E9%80%A0%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84bluetooth%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</guid>
      <description>【Bluetooth|蓝牙开发】一、开篇词 | 打造全网最详细的Bluetooth开发教程 #  1、前言 #  大家好，我是董哥！
随着物联网技术的快速发展，WiFi、蓝牙成了物联网通信主力军，但是不得不说，这两个技术的门槛还是比较高的，尤其是蓝牙，单单其官方文档，就有将近3000Page，让人望而生畏！
纵观全网，蓝牙技术的学习有三大难点：
 其一：学习资料之杂 其二：极少有系统学习蓝牙的文章 其三：蓝牙协议晦涩难懂  这样就导致了蓝牙学习成本之高，劝退人数之多。
因此，为了让初学者快速上手并且掌握蓝牙开发相关技术，我也根据自己的开发经验，精心打造了这一期专栏，主要目的是可以帮助大家零基础入门蓝牙开发，并且可以创建一个交流平台，以供大家交流！
本专栏从四个大方面来学习蓝牙技术：蓝牙基础知识，蓝牙协议栈，蓝牙调试方法，蓝牙应用。我也一定会尽最大努力，帮助大家快速敲开蓝牙开发的大门。
2、蓝牙综合介绍 #  下面我们看一下零基础入门蓝牙开发的学习步骤，希望能够帮助到大家！！！
3、精华文章汇总 #  ==为了方便大家快速找到文章，这里按照学习流程进行汇总，点击即可访问！==
   章节 内容     1、开篇词 1. 文章总览   2、蓝牙开发入门 2.1 蓝牙基本概念    2.2 蓝牙发展历程    2.3 常见蓝牙架构   3. 蓝牙协议栈总览 2.1 从两个视角，了解蓝牙协议栈   4. 蓝牙协议栈——物理层 3.1 物理层的划分   5. 蓝牙协议栈——链路层 4.</description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】一、开篇词|Linux驱动开发新手必读</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%80linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%89%8B%E5%BF%85%E8%AF%BB/</link>
      <pubDate>Fri, 19 Jan 2024 20:26:20 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%80linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%89%8B%E5%BF%85%E8%AF%BB/</guid>
      <description>【LED子系统深度剖析】一、开篇词|Linux驱动开发新手必读 #  1、前言 #  大家好，我是董哥！
俗话说：“万丈高楼平地起”，对于我们刚学习Linux驱动开发的小伙伴，Linux驱动开发的基础至关重要，无论我们是学习51单片机、STM32还是ARM，点灯的地位还是毋庸置疑的。
在Linux驱动开发的学习过程中，点灯对于大多数人来说，对着教程照葫芦画瓢，还是能快速点亮一颗LED灯的，但是你真的明白，一颗小小LED灯的背后，到底执行了哪些动作吗，Linux内核是如何管理的呢？
今天，作为在芯片原厂工作的我，有义务带着大家，深入扒一扒LED子系统的工作原理！
 总结系列文章，花费时间较长，希望大家尊重原创！
 2、LED子系统开发详细介绍 #  该系列文章整体预览如下：
3、LED子系统开发文章汇总 #  为了方便大家快速找到文章，这里按照学习流程进行汇总，点击即可访问！
   章节 内容     1、开篇词 1. 文章总览   2、LED子系统框架分析 2.1 裸机处理    2.2 LED子系统框架    2.3 目录结构及核心文件   3、硬件驱动层详解 3.1 gpio_led_probe分析    3.2 gpio_leds_create分析    3.3 create_gpio_led分析    3.4 数据结构之间的关系，以及实现流程   4、核心层——led-class.</description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】一、内核锁的由来</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%80%E5%86%85%E6%A0%B8%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5/</link>
      <pubDate>Thu, 18 Jan 2024 23:01:55 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%80%E5%86%85%E6%A0%B8%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5/</guid>
      <description>【深入理解Linux锁机制】一、内核锁的由来 #  在Linux设备驱动中，我们必须要解决的一个问题是：多个进程对共享资源的并发访问，并发的访问会导致竞态。
1、并发和竞态 #  并发（Concurrency）：指的是多个执行单元同时、并行的被执行。
竞态（RaceConditions）：并发执行的单元对共享资源的访问，容易导致竞态。
共享资源：硬件资源和软件上的全局变量、静态变量等。
解决竞态的途径是：保证对共享资源的互斥访问。
互斥访问：一个执行单元在访问共享资源的时候，其他执行单元被禁止访问。
临界区（Critical Sections）：访问共享资源的代码区域成为临界区。临界区需要以某种互斥机制加以保护。
常见的互斥机制包括：中断屏蔽，原子操作，自旋锁，信号量，互斥体等。
 2、竞态发生的场合 #  2.1 多对称处理器（SMP）的多个CPU之间 #  多个CPU使用共同的系统总线，可以访问共同的外设和存储器。在SMP的情况下，多核（CPU0、CPU1）的竞态可能发生于：
 CPU0的进程和CPU1的进程之间 CPU0的进程和CPU1的中断之间 CPU0的中断和CPU1的中断之间   2.2 单CPU内，该进程与抢占它的进程之间 #  在单CPU内，多个进程并发执行，当一个进程执行的时间片耗尽，也有可能被另一个高优先级进程打断，会发生竞态，即所谓的调度引发竞态。
 2.3 中断（软中断、硬中断、Tasklet、底半部）与进程之间 #  当一个进程正在执行，一个外部/内部中断（软中断、硬中断、Tasklet等）将其打断，会导致竞态发生。
 3、编译乱序和执行乱序 #  除了并发访问导致的竞态外，还需要了解编译器和处理器的一些特点所引发的一些问题。
3.1 编译乱序 #   现代的高性能编译器，为了提高Cache命中率以及CPU的Load/Store工作效率，会对目标代码进行乱序优化，减少逻辑上不必要的访存！
因此，在打开编译器优化后，生成的汇编码并没有严格按照代码的逻辑顺序执行，这是正常的。
 为了解决编译乱序的问题，可以加入barrier()编译屏障。
顾名思义，编译屏障，也就是为了阻挡编译器的编译优化，加入barrier()编译屏障，即可保证正确的执行顺序。
编译屏障代码实现如下：
#define barrier() __asm__ __volatile__(&amp;#34;&amp;#34;: : :&amp;#34;memory&amp;#34;) 这里详细解释一下barrier的汇编实现：
 __asm__：向编译器说明在此插入汇编代码 __volatile__：用于告诉编译器，严禁将此处的汇编语句与其它的语句重组合优化。 (&amp;quot;&amp;quot;: : :&amp;quot;memory&amp;quot;)：一条汇编语句，第一个:前为汇编指令，这里是空操作；第二个:前表示输出操作数，为空；第三个冒号前为输入操作数，也是要修改的寄存器；最后memory表示该指令对内存进行访问，该指令确保了命令之前的内存操作需要完全执行，不被优化。   使用案例：</description>
    </item>
    
    <item>
      <title>【NVMEM子系统深入剖析】一、Efuse介绍及安全启动浅析</title>
      <link>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%80efuse%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8%E6%B5%85%E6%9E%90/</link>
      <pubDate>Thu, 18 Jan 2024 22:27:35 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%80efuse%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8%E6%B5%85%E6%9E%90/</guid>
      <description>【NVMEM子系统深入剖析】一、Efuse介绍及安全启动浅析 #  1、Efuse是什么 #  eFuse(electronic fuse)：电子保险丝，熔丝性的一种器件，属于一次性可编程存储器。
之所以成为eFuse，因为其原理像电子保险丝一样，CPU出厂后，这片eFuse空间内所有比特全为1，如果向一位比特写入0，那么就彻底烧死这个比特了，再也无法改变它的值，也就是再也回不去 1 了。
 一般OEM从CPU厂商购买芯片后，一般都要烧写eFuse，用于标识自己公司的版本信息，运行模式等相关信息。
同时，由于其一次性编程的特性，我们又将其用在Secure Boot安全启动中。
  2、OTP是什么 #   了解完eFuse后，我们就顺便了解一下OTP
 OTP(One Time Programmable)是反熔丝的一种器件，就是说，当OTP存储单元未击穿时，它的逻辑状态为0；当击穿时，它的逻辑状态为1，也属于一次性可编程存储器。
它的物理状态和逻辑状态正好和eFuse相反！
两者区别如下：
  从成本上讲，eFuse器件基本上是各个Foundry厂自己提供，因此通常意味着免费或者很少的费用，而OTP器件则通常是第三方IP厂家提供，这就要收费。
  从器件面积上讲，eFuse的cell的面积更大，所以仅仅有小容量的器件可以考虑。当然如果需要大容量的，也可以多个eFuse Macro拼接，但是这意味着芯片面积的增加，成本也会增加；OTP的cell面积很小，所有相对来讲，可以提供更大容量的Macro可供使用。
  OTP 比 eFuse 安全性更好，eFuse的编程位可以通过电子显微镜看到，因此其存储的内容可以被轻易破解，但OTP在显微镜下无法区分编程位和未编程位，因此无法读取数据。
  eFuse默认导通，存储的是&amp;quot;1&amp;quot;，而OTP默认是断开，存储的是&amp;quot;0&amp;quot;，因此OTP的功耗也较eFuse小，面积也较eFuse小。
   3、什么是Secure Boot #   上面我们也了解过了，efuse主要用于记录一些OEM的产品信息，并且也会用于安全启动，那么安全启动是什么，为什么要做安全启动？
 安全启动Secure Boot，其主要目的是：以限制消费者能力，防止消费者从软硬件层面，对产品的部分关键系统进行读写，调试等高级权限，达到对产品的商业保密，知识产权的保护。
安全启动的安全模型是建立在消费者是攻击者的假设之上，一般常见的操作有：
 刷机安装自定义的操作系统 绕过厂家封闭的支付平台 绕过系统保护，复制厂家保护的数字产品。  除此之外呢，有的比较专业的消费者，还可以：
 使用数字示波器监听 CPU 和 RAM 、eMMC 之间的数据传输来读取非常底层的数据传输 而且像 eMMC 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 eMMC 编程工具来读写上面的内容。  安全启动等级也有一个上限：这个上限通常是认为攻击者不至于能够剥离芯片的封装，然后用电子显微镜等纳米级别精度的显像设备来逆向芯片的内部结构。</description>
    </item>
    
    <item>
      <title>一、内存管理的由来及思想</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/</link>
      <pubDate>Wed, 17 Jan 2024 21:09:41 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%B1%E6%9D%A5%E5%8F%8A%E6%80%9D%E6%83%B3/</guid>
      <description>Linux内存管理 | 一、内存管理的由来及思想 #  1、前言 #  《中庸》有：“九层之台，起于垒土” 之说，那么对于我们搞技术的人，同样如此！
对于Linux内存管理，你可以说没有留意过，但是它存在于我们日常开发的方方面面，你所打开的文件，你所创建的变量，你所运行的程序，无不以此为基础，它可以说是操作系统的基石；只是底层被封装的太好了，以至于我们在做开发的过程中，不需要关心的太多，哪有什么岁月静好，只是有人在负重前行罢了。
 虽然日常开发中涉及的比较少，但是作为一个合格的Linux开发者，搞懂内存管理，又显得至关重要，同时也会对嵌入式开发大有脾益，今天我们就来详细聊聊内存管理的那点事。
 该方面的文章，网上也有很多写的非常不错，但是100个人有100种理解方式，并且不同的人，基础不同，理解能力也不同，所以我写这系列的文章，也更有了意义。
 2、内存管理的由来 #   为什么要有这个概念呢？
  首先，内存管理，管理的是个什么东西？  管理的其实是我们的物理内存，也就是我们的RAM空间，在电脑上，表现为我们安装的内存条，有的人装个4G的、8G的、甚至64G的，这些就是实打实的物理空间大小，也就是我们的实际的硬件资源。
 为什么要进行管理？  做嵌入式的都知道，像我们刚开始玩的C51单片机、STM32单片机，我们将程序烧录到Flash中后，开机启动后，然后CPU会将Flash程序加载到RAM中，也就是我们的物理内存，随后我们的所有操作都是基于这一个物理内存所进行的。
那么此时：
 我们想再次运行一个一模一样的程序怎么办？ 即使运行了，那两个程序同时操作了同一个变量，值被错误修改了怎么办？  这些就是Linux内存管理要做的事情。
  顺便介绍一下 我的圈子：高级工程师聚集地，期待大家的加入。
 3、Linux内存管理思想 #  为了解决上面的一些问题，Linux采用虚拟内存管理技术。
 Linux操作系统抽象出来一个虚拟地址空间的概念，供上层用户使用，这么做的目的是为了让多个用户进程，都以为自己独享了内存空间。 而虚拟地址空间与物理地址空间的对应关系，就交给了一个MMU(Memory Managerment Unit)的家伙来管理，其主要负责将虚拟内存空间映射到真实的物理地址空间。  这么做的主要目的在于：
 让每个进程都拥有相同大小的虚拟地址空间 避免用户直接访问物理内存，导致系统崩溃  这样，我们同时执行多个进程，虽然看起来虚拟地址操作都是相同的，但是通过MMU之后，就被映射到了不同的物理地址空间，这样就解决了以上的问题。
 4、总结 #  熟悉了内存管理由来以及其思想，我们可以看出，操作系统的内存管理，主要分为以下几个方面：
 虚拟内存空间管理：我们抽象出来的虚拟地址空间，该怎么使用，该怎么管理？ 物理内存空间管理：虚拟地址映射到物理内存空间后，该如何管理，如何分配？ 如何映射：虚拟内存如何映射到物理内存，是怎么操作的，映射方法有哪些？  下面我们来一一详细探究。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【一文秒懂】Ftrace系统调试工具使用终极指南</title>
      <link>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82ftrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 13 Dec 2023 21:56:32 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82ftrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</guid>
      <description>【一文秒懂】Ftrace系统调试工具使用终极指南 #  1、Ftrace是什么 #  Ftrace是Function Trace的简写，由 Steven Rostedt 开发的，从 2008 年发布的内核 2.6.27 中开始就内置了。
Ftrace是一个系统内部提供的追踪工具，旨在帮助内核设计和开发人员去追踪系统内部的函数调用流程。
随着Ftrace的不断完善，除了追踪函数调用流程外，还可以用来调试和分析系统的延迟和性能问题，并发展成为一个追踪类调试工具的框架。
除了Ftrace外，追踪类调试工具还包括：
2、Ftrace的实现原理 #  为了帮助我们更好的使用Ftrace，我们有必要简单了解Ftrace的实现原理。
2.1 Ftrace框架图 #  Ftrace的框架图如下：
由框架图我们可以知道：
 ftrace包括多种类型的tracers，每个tracer完成不同的功能 将这些不同类型的tracers注册进入ftrace framework 各类tracers收集不同的信息，并放入到Ring buffer缓冲区以供调用。   2.2 Ftrace是如何记录信息的 #  Ftrace采用了静态插桩和动态插桩两种方式来实现。
静态插桩：
我们在Kernel中打开了CONFIG_FUNCTION_TRACER功能后，会增加一个-pg的一个编译选项，这个编译选项的作用就是为每个函数入口处，都会插入bl mcount跳转指令，使得每个函数运行时都会进入mcount函数。
 Ftrace一旦使能，对kernel中所有的函数插桩，这带来的性能开销是惊人的，有可能导致人们弃用Ftrace功能。
 为了解决这个问题，开发者推出了Dynamic ftrace，以此来优化整体的性能。
动态插桩：
 这里的动态，是指的动态修改函数指令。
  编译时，记录所有被添加跳转指令的函数，这里表示所有支持追踪的函数。 内核将所有跳转指令替换为nop指令，以实现非调试状态性能零损失。 根据 function tracer 设置，动态将被调试函数的nop指令，替换为跳转指令，以实现追踪。   总而言之，Ftrace记录数据可以总结为以下几个步骤：
 打开编译选项-pg，为每个函数都增加跳转指令 记录这些可追踪的函数，并为了减少性能消耗，将跳转函数替换为nop指令 通过flag标志位来动态管理，将需要追踪的函数预留的nop指令替换回追踪指令，记录调试信息。   3、如何使用Ftrace #  3.</description>
    </item>
    
    <item>
      <title>【Linux API 揭秘】module_init与module_exit</title>
      <link>https://uniondong.github.io/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/</link>
      <pubDate>Wed, 22 Nov 2023 22:52:44 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98module_init%E4%B8%8Emodule_exit/</guid>
      <description>【Linux API 揭秘】module_init与module_exit #   Linux Version：6.6
Author：Donge
Github：linux-api-insides
  1、函数作用 #  module_init和module_exit是驱动中最常用的两个接口，主要用来注册、注销设备驱动程序。
并且这两个接口的实现机制是一样的，我们先以module_init为切入点分析。
 2、module_init函数解析 #  2.1 module_init #  #ifndef MODULE /** * module_init() - driver initialization entry point * @x: function to be run at kernel boot time or module insertion * * module_init() will either be called during do_initcalls() (if * builtin) or at module insertion time (if a module). There can only * be one per module.</description>
    </item>
    
    <item>
      <title>一、uboot基础了解</title>
      <link>https://uniondong.github.io/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</link>
      <pubDate>Fri, 17 Nov 2023 20:50:32 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/uboot/%E4%B8%80uboot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</guid>
      <description>一、uboot基础了解 #  1. U-boot是什么 #  U-Boot，全称 Universal Boot Loader，是遵循GPL条款的从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的 开放源码项目。
U-boot，是一个主要用于嵌入式系统的引导加载程序，可以支持多种不同的计算机系统结构，其主要作用为：==引导系统的启动！==目前，U-Boot不仅支持Linux系统的引导，还支持NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android等多种嵌入式操作系统。
2. U-boot主要特性及功能 #   开放：开放的源代码 多平台：支持多种嵌入式操作系统，如Linux、NetBSD、android等 生态：有丰富的设备驱动源码，如以太网、SDRAM、LCD等，同时也具有丰富的开发文档。  3. U-boot下载地址 #  Uboot开发源码：
  https://source.denx.de/u-boot/u-boot
  https://ftp.denx.de/pub/u-boot/
  其他厂商定制的uboot源码：
 野火  4. U-boot目录结构 #     目录 含义     arch 各个厂商的硬件信息，目录下包括支持的处理器类型   arch/arm/cpu/xxx **每一个子文件夹，包含一种cpu系列。**每个子文件夹下包含cpu.c（CPU初始化），interrupts.c（设置中断和异常），start.S（U-boot的启动文件，早期的初始化）。   board 与开发板有关，每一个子文件夹代表一个芯片厂家，芯片厂家下，每一个子文件夹，表示一个开发板   common 存放与处理器体系无关的通用代码，可以说为通用核心代码！   cmd 存放uboot的相关命令实现部分   drivers 存放外围芯片驱动，网卡，USB等   disk 存放驱动磁盘的分区处理代码   fs 本目录下存放文件系统相关代码，每一个子文件夹表示文件系统   net 网络协议相关代码   doc uboot说明文档   include 各种头文件   post 上电自检代码   api 外部扩展程序的API和示例   tools 编译S-Record或者U-boot镜像的相关工具    5.</description>
    </item>
    
    <item>
      <title>Soc的Bring Up流程</title>
      <link>https://uniondong.github.io/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://uniondong.github.io/docs/embeded_tech/embeded_interview/soc%E7%9A%84bringup%E6%B5%81%E7%A8%8B/</guid>
      <description>1、Bring Up流程 #  SOC (System on a Chip) bring-up是一个复杂的过程，涉及到硬件、固件和软件的集成和验证，以下是一个基于BROM，SPL，UBOOT和Linux的启动流程的概述：
 BROM (Boot Read-Only Memory)启动：启动的最初阶段，在这个阶段，系统会执行芯片ROM里面的代码，这部分代码主要用来检查启动模式，包括NOR、Nand、Emmc等，然后从对应的存储介质中加载SPL(Secondary Program Loader)代码。 SPL (Secondary Program Loader)启动：SPL属于Uboot的一部分，它的主要作用就是：初始化硬件并加载完整的U-boot，主要体现在初始化时钟、看门狗、DDR、GPIO以及存储外设，最后将U-boot代码加载到DDR中执行。 U-Boot启动：U-boot的主要作用是：引导加载Kernel和DTS。U-boot在启动之后，同样初始化Soc硬件资源，然后会计时等待，并执行默认的启动命令，将Kernel和DTS信息从存储介质中读取出来并加载到内存中执行。 Kernel启动：在U-Boot加载了内核映像和设备树之后，系统会启动Linux。在这个阶段，系统会初始化各种硬件设备，加载驱动程序并启动用户空间应用程序。   更多干货可见：高级工程师聚集地，助力大家更上一层楼！
  2、常见问题 #  Q：为什么上一个阶段已经初始化了硬件资源，下一个阶段为何重复初始化？
A：
  每个阶段的硬件初始化，其目标和需求都不同，硬件配置也会不一样，因此在不同阶段进行不同的初始化。
  硬件状态可能会改变，在SOC启动过程中，硬件状态可能会因为电源管理、时钟管理等原因而改变，这可能需要在每个阶段都重新初始化以确保其正确工作
  为了保证硬件资源的可靠性，最好每个阶段都重新初始化一次
   Q：U-boot加载内核时，会进行重定位的操作，这一操作有何意义？
A：
 U-boot的重定位，主要作用是为了 给内核提供一个连续的、大的内存空间，供内核和其他应用程序使用 U-boot的加载过程分两个阶段，即：SPL和U-boot，   在SPL阶段，主要将U-boot代码从Flash中加载到RAM指定位置 在U-boot阶段，U-boot会将自身从RAM的开始部分移动到RAM的末尾，占用高地址空间，从而让低地址空间可以作为一个连续的，大的内存空间供内核和其他应用程序使用。   Q：在Bring Up中，为了保证启动时间，如何裁剪？
A：
 启动时间的裁剪是一个重要的步骤，其主要目标是缩短从电源打开到操作系统完全启动的时间。
  优化Bootloader：减小Bootloader的代码大小，减少硬件初始化（只初始化必要硬件设备）等 优化Kernel：减少启动服务数量，优化服务的启动顺序，使用预加载技术等方法来实现。 使用快速启动模式：一些SOC支持快速启动模式，这种模式下，SOC会跳过一些不必要的硬件初始化和自检过程，从而更快地启动。 使用休眠和唤醒技术：一些SOC还支持休眠和唤醒技术，这种技术可以将系统的状态保存到非易失性存储器中，然后关闭系统。当系统再次启动时，可以直接从非易失性存储器中恢复系统的状态，从而更快地启动。  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>【一文秒懂】Linux设备树详解</title>
      <link>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 19 Jan 2024 21:43:13 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</guid>
      <description>【一文秒懂】Linux设备树详解 #  1、Linux设备树概念 #  Linux内核是从V2.6开始引入设备树的概念，其起源于OF:OpenFirmware， 用于描述一个硬件平台的硬件资源信息，这些信息包括：CPU的数量和类别、内存基地址和大小、总线和桥、外设连接、中断控制器和中断使用情况、GPIO控制器和GPIO使用情况、Clock控制器和Clock使用情况等等。
官方说明：
 The &amp;ldquo;Open Firmware Device Tree&amp;rdquo;, or simply Device Tree (DT), is a data structure and language for describing hardware.
设备树是一种数据结构和一种用于描述硬件信息的语言。
 设备树的特点：
 实现驱动代码与设备硬件信息相分离。 通过被bootloader(uboot)和Linux传递到内核， 内核可以从设备树中获取对应的硬件信息。 对于同一SOC的不同主板，只需更换设备树文件即可实现不同主板的无差异支持，而无需更换内核文件，实现了内核和不同板级硬件数据的拆分。   2、设备树的由来 #  明白了设备树的概念，不妨思考一下：为什么要引入设备树？
在Linux内核v2.6版本以前，ARM架构用于描述不同的硬件信息的文件都存放在arch/arm/plat-xxx和arch/arm/mach-xxx文件夹下，如下：
在这些文件内，都是通过手动定义不同的硬件设备，步骤非常繁琐
这样就导致了Linux内核代码中充斥着大量的垃圾代码，因为不同的板级他们的硬件信息都不相同，这些都是硬件特有的信息，对内核而言没有任何的意义，但是往往这部分代码特别的多，造成内核的冗余。
设备树的引入就是为了解决这个问题，通过引入设备树，我们可以直接通过它来传递给Linux，而不再需要内核中大量的垃圾代码。
 3、设备树组成 #   整个设备树牵涉面比较广，即增加了新的用于描述设备硬件信息的文本格式，又增加了编译这个文本的工具，同时还得支持Bootloader解析设备树，并将信息传递给内核。
 整个设备树包含DTC（device tree compiler），DTS（device tree source）和DTB（device tree blob）。
 DTS（device tree source）  DTS是一种ASCII文本格式的设备树描述，在ARM Linux中，一个dts文件对应一个ARM的设备，该文件一般放在arch/arm/boot/dts/目录中。
 当然，我们还会看到一些dtsi文件，这些文件有什么用呢？</description>
    </item>
    
    <item>
      <title>【MMC子系统】二、EMMC协议</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%8Cemmc%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 19 Jan 2024 21:14:30 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%8Cemmc%E5%8D%8F%E8%AE%AE/</guid>
      <description>【MMC子系统】 二、EMMC协议 #  1、前言 #  在上一节，我们知道EMMC、SD、SDIO三种规范都是在MMC规范之上发展而来，协议相差不大，所以Linux Kernel才能使用MMC子系统来统一管理！
下面，我们以MMC协议为例，来了解一下相关协议!
 2、EMMC基本了解 #  2.1 物理线路 #     物理接口 接口含义     CLK 时钟线，此信号的每一周期控制命令线上的 1 bit 传输，以及所有数据线上 1 bit（1x） 或 2 bit（2x）传输。   CMD 命令线，此信号是双向命令通道，用于设备初始化和命令传输。CMD信号有两种工 作模式：用于初始化模式开漏模式和快速命令传输推拉模式。   DAT0-7 这些是双向的数据通道。DAT 信号以推拉模式工作。缺省状态，只有DAT0处于推拉模式，DAT1-7处于上拉（内含上拉），进入4bit后，DAT0-3处于推拉     2.2 EMMC相关寄存器了解 #   2.3 其他特性了解 #    读写模式：单块读写，多块读写
  寻址方式：字节寻址和扇区寻址，字节寻址允许最大2GB，容量超过2GB的，使用扇区（512B）寻址
  电压模式：支持高电压和双电压模式
  支持增强分区模式等</description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】二、蓝牙开发入门</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%8C%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 19 Jan 2024 20:59:56 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%8C%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</guid>
      <description>【Bluetooth|蓝牙开发】二、蓝牙开发入门 #  1、蓝牙基础概念 #  蓝牙，是一种利用低功率无线电，支持设备短距离通信的无线电技术，能在包括移动电话、PDA、无线耳机、笔记本电脑、相关外设等众多设备之间进行无线信息交换，蓝牙工作在全球通用的2.4GHz ISM（即工业、科学、医学）频段，使用IEEE802.11协议。
 2、蓝牙发展历程 #  自1994年由爱立信推出至今，蓝牙技术已经走过了20个岁月。从最初的Bluetooth V1.0，到Bluetooth V5.2，经历了近9个版本的修订后，发展为当前的状况。
 “蓝牙”的形成背景是这样的：
 1998 年 5 月，爱立信、诺基亚、东芝、 IBM和英特尔公司等五家著名厂商， 在联合开展短程无线通信技术的标准化活动时提出了蓝牙技术，其宗旨是提供一种短距离、 低成本的无线传输应用技术。
芯片霸主 Intel 公司负责半导体芯片和传输软件的开发，爱立信负责无线射频和移动电话软件的开发， IBM 和东芝负责笔记本电脑接口规格的开发。
1999 年下半年，著名的业界巨头微软、摩托罗拉、三星、朗讯与蓝牙特别小组的五家公司共同发起成立了蓝牙技术推广组织，从而在全球范围内掀起了一股“蓝牙”热潮。
全球业界即将开发一大批蓝牙技术的应用产品， 使蓝牙技术呈现出极其广阔的市场前景，并预示着 21 世纪初将迎来波澜壮阔的全球无线通信浪潮。
  第一代蓝牙：关于短距离通讯早期的探索，使用的是BR技术，此时蓝牙的理论传输速率，只能达到721.2Kbps。 第二代蓝牙：新增的 EDR（Enhanced Data Rate）技术，使得蓝牙设备的传输率可达 3Mbps。 第三代蓝牙：核心是 AMP（Generic Alternate MAC/PHY），这是一种全新的交替射频技术，支持动态地选择正确射频，传输速率高达 24Mbps 第四代蓝牙：主推” Low Energy”低功耗， BLE（Bluetooth Low Energy）低功耗功能 第五代蓝牙：开启「物联网」时代大门，在低功耗模式下具备更快更远的传输能力   3、蓝牙技术概述 #  蓝牙协议包括两种技术：BR：Basic Rate和LE：Low Energy。这两种技术都包括搜索（discovery）管理、连接（connection）管理等机制，但它们是相互独立的，不能互通的技术！
 厂商如果只实现了一种，那么只能与同样实现该技术的设备互通。
如果厂商要确保能和所有的蓝牙设备互通，那么就只能同时实现两种技术，而不去管是否真的需要。
  3.1 Basic Rate(BR) #  BR：Basic Rate是正宗的蓝牙技术，可以包括**可选（optional）的EDR（Enhanced Data Rate）技术，以及交替使用的（Alternate）**的MAC（Media Access Control）层和PHY层扩展（简称AMP（Alternate MAC and PHY layer extension））。</description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】二、LED子系统框架分析</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%8Cled%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 19 Jan 2024 20:27:15 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%8Cled%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</guid>
      <description>【LED子系统深度剖析】二、LED子系统框架分析 #  1、前言 #  我们学习嵌入式，无论是C51、STM32或者是ARM，都是从点灯开始的，点灯在嵌入式中的地位等同于Hello World在各大语言中的地位！
虽然LED功能简单，但是其麻雀虽小，五脏俱全，在学习Linux驱动开发的过程中，学习LED子系统，往往也能够起到牵一发而动全身的作用，也更有益于大家熟悉驱动开发的框架！
2、LED裸机处理 #  我们在学习Linux驱动框架的时候，第一步要做的就是去掉子系统的面纱，先弄明白裸机处理的流程！
有嵌入式经验的朋友，对LED的裸机在清楚不过了，上面是LED的硬件电路，通常一端接到VCC，一端接到GPIO，当GPIO拉低时，LED亮；当GPIO拉高时，LED灭。
在这里裸机我们不过多了解了，目的在于窥探LED子系统。
3、LED子系统框架 #  框架是什么？
框架是一个规范，为我们开发者增加限制的同时，也是为了更好的开发新的程序，新的功能，其目的主要是：将不变的成分剥离开来，固化进框架，让开发者做最少的事情!
框架所处的位置，正如上图所示，由下往上看：
 Hardware：我们的硬件设备，指的是LED 硬件驱动层：是直接操作硬件的实现，用于驱动硬件，实现相应的功能，并且将硬件设备注册进框架之中。 核心层：将LED进行统一管理，提供注册，注销，管理LED等相关接口，起到呈上启下的作用，方便上层调用。 用户层：用户通过sysfs文件系统中对应的文件节点，能够直接控制LED的亮灭。  4、LED子系统目录结构及核心文件 #  了解完LED子系统框架之后，我们来分析一下其相关的目录结构！
ketnel │ └── driver │ │ └── leds │ │ │ ├──	Makefile │ │ │ ├──	led-core.c │ │ │ ├──	led-gpio.c │ │ │ ├──	led-class.c │ │ │ ├──	led-triggers.c │ │ │ ├──	...... │ │ │ └── trigger │ │ │ │ ├── ledtrig-cpu.</description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】二、中断屏蔽</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%8C%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD/</link>
      <pubDate>Thu, 18 Jan 2024 23:02:05 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%8C%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD/</guid>
      <description>【深入理解Linux内核锁】二、中断屏蔽 #   上一篇了解了内核锁的由来，本篇文章主要来讲一下中断屏蔽的底层实现以及原理。
  1、中断屏蔽思想 #  中断屏蔽，正如其名，屏蔽掉CPU的中断响应功能，解决并发引起的竞态问题。
 在进入临界区前屏蔽中断，这么做有什么好处，以及有什么弊端？
 好处在于：
 解决了进程与中断之间的并发：保证在执行临界区代码时，不被中断所打断。 解决了进程与进程之间调度的并发：系统的进程调度与中断息息相关，同时也限制了系统进程的并发，解决了系统进程并发带来的竞态问题。  弊端在于：
 各类中断类型较多，一棒子打死影响大：Linux内核中，除了系统进程调度依赖中断，还有一些异步I/O等众多操作都依赖中断，因此长时间屏蔽中断是很危险的，会对系统造成严重影响，因此也要求临界区代码要简短。 解决的不够完善：关闭中断能够解决进程调度、中断引发的竞态，但是这些都是单CPU内部的，对于SMP对称多处理器，仍然不可避免的会收到其他CPU的中断。因此，并不能解决SMP多CPU引发的竞态。  因此，单独使用中断屏蔽通常不是一种值得推荐的避免竞态的方法
 2、Linux内核中断屏蔽的实现 #  2.1 Linux内核提供的API接口 #   关于中断屏蔽，Linux内核所提供的接口如下：
 local_irq_enable()	//	使能本CPU的中断 local_irq_disable()	//	禁止本CPU的中断 local_irq_save(flags)	//	禁止本CPU的中断，并保存CPU中断位的信息 local_irq_restore(flags)	//	使能本CPU的中断，并恢复CPU中断位的信息 local_bh_disable(void)	//	禁止本CPU底半部中断 local_bh_enable(void) //	使能本CPU底半部中断 文件位置：kernel/include/linux/irqflags.h
 local_irq_enable与local_irq_disable：直接打开/关闭本CPU内的中断，包括了顶半部和底半部中断的打开和关闭。 local_irq_save与local_irq_restore：直接打开/关闭本CPU中断，并且保存中断屏蔽前的状态，便于后续恢复 local_bh_enable与local_bh_disable：直接打开/关闭本CPU内的底半部中断   2.2 API接口实现分析 #   因为中断屏蔽与底层芯片架构有关，不同架构处理方式不同，我们以ARM为例
 2.2.1 local_irq_enable #  #define local_irq_enable()	do { raw_local_irq_enable(); } while (0)  #define raw_local_irq_enable()	arch_local_irq_enable()  #define arch_local_irq_enable arch_local_irq_enable static inline void arch_local_irq_enable(void) { asm volatile( &amp;#34;	cpsie i	@ arch_local_irq_enable&amp;#34; : : : &amp;#34;memory&amp;#34;, &amp;#34;cc&amp;#34;); } 函数介绍：local_irq_enable函数用于将CPSR寄存器中的中断使能位设为1，从而使得CPU能够响应中断。</description>
    </item>
    
    <item>
      <title>【NVMEM子系统深入剖析】二、NVMEM驱动框架</title>
      <link>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%BA%8Cnvmem%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 18 Jan 2024 22:27:58 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%BA%8Cnvmem%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</guid>
      <description>【NVMEM子系统深入剖析】二、NVMEM驱动框架 #  1、前言 #   NVMEM SUBSYSTEM，该子系统整体架构不算太大，还是比较容易去理解的，下面我们一起去一探究竟！
 NVMEM（Non Volatile Memory），该子系统主要用于实现EEPROM、Efuse等非易失存储器的统一管理。
在早期，像EEPROM驱动是存放于/drivers/misc目录下，由于没有做到好的抽象，每次需要去访问相应内存空间，都需要去复制几乎一样的代码，去注册sysfs，这是一个相当大的抽象泄露。
NVMEM子系统就是为了解决以往的抽象泄露问题。
 2、驱动框架 #   该驱动框架较为简单，也适合初学者去熟悉基本的驱动框架。
 应用层：可以通过用户空间所提供的文件节点，来读取或者修改nvmem存储器的数据。
NVMEM 核心层：统一管理NVMEM设备，向上实现文件系统接口数据的传递，向下提供统一的注册，注销nvmem设备接口。
NVMEM 总线驱动：注册NVMEM总线，实现NVMEM控制器的底层代码实现。
TIP：
nvmem子系统提供读写存储器的接口有两种，一种是通过文件系统读写，一种是在内核驱动直接读写。
对于EEPROM，其可以进行读写操作，而对于efuse，更多用于读取密钥信息，进而判断镜像是否被篡改，在用户空间是不允许被更改的。
这种是通过驱动提供的开放接口，直接获取指定位置的数据，详细的后面展开来说。
 3、源码目录结构 #  ketnel │ └── driver │ │ └── nvmem │ │ │ ├──	core.c	# NVMEM核心层 │ │ │ ├──	rockchip-efuse.c	# NVMEM总线驱动  4、用户空间下的目录结构 #  我们可以在用户空间去读取/写入数据，其所在的目录：/sys/bus/nvmem/devices/dev-name/nvmem
hexdump /sys/bus/nvmem/devices/qfprom0/nvmem 0000000 0000 0000 0000 0000 0000 0000 0000 0000 * 00000a0 db10 2240 0000 e000 0c00 0c00 0000 0c00 0000000 0000 0000 0000 0000 0000 0000 0000 0000 .</description>
    </item>
    
    <item>
      <title>CPU体系架构</title>
      <link>https://uniondong.github.io/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 17 Jan 2024 21:39:15 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/embeded_tech/embeded_interview/cpu%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</guid>
      <description>CPU体系架构 #  2.1 CPU体系架构有哪些？ #   我们常见的CPU架构有哪些呢？
 如果我们熟悉Linux，那么这个问题肯定不难回答！
我们查看内核目录下的arch子目录，就可以看到Linux所支持的处理器架构，基本属于我们常见的类型了。
# ls ./arch alpha arc arm arm64 c6x h8300 hexagon ia64 Kconfig m68k microblaze mips nds32 nios2 openrisc parisc powerpc riscv s390 sh sparc um unicore32 x86 xtensa  准确来说，CPU处理器架构主要有以下几种类型：
 CISC（复杂指令集计算机）：CISC架构的CPU设计理念是尽可能减少程序指令的数量，以降低CPU和内存之间的通信频率。这种架构的一个显著特点是拥有大量的寄存器和复杂的指令集。Intel的x86架构就是一个典型的CISC架构 RISC（精简指令集计算机）：RISC架构的CPU设计理念是通过简化指令集来提高CPU的运行效率。这种架构的一个显著特点是拥有较少的寄存器和简单的指令集。ARM架构就是一个典型的RISC架构 MISC（中间指令集计算机）：MISC架构的CPU设计理念是在CISC和RISC之间寻找一个平衡点，既不过于复杂也不过于简单。这种架构的一个显著特点是指令集的复杂度介于CISC和RISC之间 VLIW（超长指令字计算机）：VLIW架构的CPU设计理念是通过增大指令长度来提高并行执行的可能性。这种架构的一个显著特点是指令长度远大于其他架构的CPU EPIC（显式并行指令计算）：EPIC架构的CPU设计理念是通过显式标记并行指令来提高CPU的运行效率。这种架构的一个显著特点是指令集中包含了并行执行的信息。Intel的Itanium架构就是一个典型的EPIC架构 超标量架构：超标量架构的CPU设计理念是通过在一个时钟周期内执行多条指令来提高CPU的运行效率。这种架构的一个显著特点是CPU内部包含了多个执行单元，可以同时执行多条指令 超线程技术：超线程技术是Intel公司为其部分CPU所采用的一种使单一处理器像多个逻辑处理器那样并行处理多个线程的技术 多核心架构：多核心架构的CPU设计理念是在一个CPU芯片内集成多个处理器核心，以提高并行处理能力。这种架构的一个显著特点是CPU内部包含了多个独立的处理器核心，每个核心可以独立执行指令   这里就有一个疑问，我们什么时候说RISC架构，什么时候说ARM架构，这两个有什么区别呢？
 以ARM和RISC为例：
 ARM架构和RISC架构的主要区别在于ARM实际上是RISC的一个具体实现，而RISC则是一个更广泛的处理器设计理念。换句话说，ARM是RISC的一个子集。
同理，X86架构是CISC的一个子集。
 2.2 常见的问题 #  Q1：你所熟知的处理器架构有哪些？
我们常见的处理器架构有ARM、X86、mips架构等；
 Q2：STM32属于什么架构的？
STM32是ST公司开发的32位微控制器集成电路，基于 ARM 的 Cortex-M 系列内核。因此，STM32 属于 ARM 架构的微控制器。</description>
    </item>
    
    <item>
      <title>【一文秒懂】TOP命令详解</title>
      <link>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 17 Jan 2024 21:37:13 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>【一文秒懂】TOP命令详解 #  1、Top命令介绍 #  Linux系统中，Top命令主要用于实时运行系统的监控，包括Linux内核管理的进程或者线程的资源占用情况。
这个命令对所有正在运行的进程和系统负荷提供不断更新的概览信息，包括系统负载、CPU利用分布情况、内存使用、每个进程的内容使用情况等信息。
 2、Top命令使用 #  Top的命令介绍如下：
top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w [cols] 常用的Top指令有：
top：启动top命令 top -c：显示完整的命令行 top -b：以批处理模式显示程序信息 top -S：以累积模式显示程序信息 top -n 2：表示更新两次后终止更新显示 top -d 3：设置信息更新周期为3秒 top -p 139：显示进程号为139的进程信息，CPU、内存占用率等 top -n 10：显示更新十次后退出 除此之外，在top进程运行过程中，两个最重要的功能是查看帮助（h 或 ？）和退出（q 或 Ctrl+C）。
 3、Top信息详解 #  top展示界面由从上到下3部分组成
 概览区域 表头 任务区域 还有一个输入/消息行，位于概览区域和表头之间。  3.1 概览区详解 #  top - 14:46:08 up 5:46, 1 user, load average: 0.</description>
    </item>
    
    <item>
      <title>二、虚拟地址空间布局</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 17 Jan 2024 21:13:17 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80/</guid>
      <description>Linux内存管理 | 二、虚拟地址空间布局 #  上一章，我们了解了内存管理的由来以及核心思想，下面我们按照顺序，先来介绍一下Linux虚拟内存空间的管理。
 同样，我们知道Linux内核抽象出来虚拟内存空间，主要是为了让每个进程都独享该空间，那虚拟内存空间是如何布局的呢？
 前提：针对于不同位数的CPU，寻址能力不同，抽象出来的虚拟内存空间大小也不同，我们以常见的32位的CPU为例。
  1、虚拟内存空间布局 #  对于32位的CPU，寻址范围为0~2^32，也就是0x00000000-0xFFFFFFFF，即最多抽象出来4G的虚拟内存空间。
这4GB的内存空间，在Linux中，又分为用户空间和内核空间，其中0x0000000-0xBFFFFFFF，共3G为用户空间，0xC00000000-0xFFFFFFFF，共1G为内核空间，如下：
无论内核空间还是用户空间，其仍然是在虚拟内存空间基础之上进行划分的，其直接访问的依旧都是虚拟地址，而非物理地址！
我们编写代码后，所生成的可执行程序，运行之后就成为一个系统进程，我们在&amp;quot;虚&amp;quot;的角度来看，每个进程都是独享这4G虚拟地址空间的，
 2、用户态空间布局 #  如上所述，用户空间在虚拟内存中分布在0x0000000-0xBFFFFFFF，大小为3G。
每一个用户进程，按照访问属性一致的地址空间存放在一起的原则，划分成5个不同的内存区域（访问属性一致指的是：可读，可写，可执行）：
 代码段：Text Segment，也就是我们的二进制程序，代码段需要防止在运行时被非法修改，所以该段为只读。 数据段：Data Segment，主要存放初始化了的变量，主要包括：静态变量和全局变量，该段为读写。 BSS段：BSS Segment，主要存放未初始化的全局变量，在内存中 bss 段全部置零，该段为读写。 堆段：Heap Segment，主要存放进程运行过程中动态分配的内存段，大小不固定，可动态扩张和缩减，通常使用malloc和free来分配释放，并且堆的增长方向是向上的。 文件映射和匿名映射段：Memory Mapping Segment，主要存放进程使用到的文件或者依赖的动态库，从低地址向上增长。 栈段：Stack Segment，主要存放进程临时创建的局部变量，函数调用上下文信息等，栈向下增长。  一个可执行程序，可以通过size命令，查看编译出来的可执行文件大小，其中包括了代码段，数据段等数据信息，如下:
donge@Donge:$ size Donge-Demo text data bss dec hex filename 12538 1916 43632 58086 e2e6 Donge-Demo  text：代码段大小 data：数据段大小 bss：bss段大小 dec：十进制表示的可执行文件大小 hex：十六进制表示的可执行文件大小   运行该程序后，可以通过cat /proc/PID/maps命令，或者pmap PID命令，来查看该进程在虚拟内存空间中的分配情况，其中PID为进程的PID号，如下:
donge@Donge:$ cat /proc/16508/maps 55976ff9e000-55976ffa0000 r--p 00000000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa0000-55976ffa2000 r-xp 00002000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa2000-55976ffa3000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa3000-55976ffa4000 r--p 00004000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa4000-55976ffa5000 rw-p 00005000 08:10 184922 /home/donge/WorkSpace/Program/Donge_Programs/Donge_Demo/build/Donge-Demo 55976ffa5000-55976ffaf000 rw-p 00000000 00:00 0 559771d91000-559771db2000 rw-p 00000000 00:00 0 [heap] 7fec1ad84000-7fec1ad87000 rw-p 00000000 00:00 0 7fec1ad87000-7fec1adaf000 r--p 00000000 08:10 22282 /usr/lib/x86_64-linux-gnu/libc.</description>
    </item>
    
    <item>
      <title>【Linux API 揭秘】container_of函数详解</title>
      <link>https://uniondong.github.io/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 13 Dec 2023 21:56:32 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_api/linux-api-%E6%8F%AD%E7%A7%98container_of%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>【Linux API 揭秘】container_of函数详解 #   Linux Version：6.6
Author：Donge
Github：linux-api-insides
  1、container_of函数介绍 #  container_of可以说是内核中使用最为频繁的一个函数了，简单来说，它的主要作用就是根据我们结构体中的已知的成员变量的地址，来寻求该结构体的首地址，直接看图，更容易理解。
 下面我们看看linux是如何实现的吧
 2、container_of函数实现 #  /** * container_of - cast a member of a structure out to the containing structure * @ptr:	the pointer to the member. * @type:	the type of the container struct this is embedded in. * @member:	the name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost.</description>
    </item>
    
    <item>
      <title>二、uboot启动流程分析</title>
      <link>https://uniondong.github.io/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 17 Nov 2023 22:11:57 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/uboot/%E4%BA%8Cuboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>二、uboot启动流程分析 #   上一篇文章：（一）uboot基础了解 下一篇文章：（三）Uboot驱动模型
 同大多数的Bootloader一样，uboot的启动过程也分为BL1、BL2两个阶段，分别对应着SPL和Uboot。
SPL（BL1阶段）：负责开发板的基础配置和设备初始化，并且搬运Uboot到内存中，由汇编代码和少量的C语言实现
Uboot（BL2阶段）：主要负责初始化外部设备，引导Kernel启动，由纯C语言实现。
 我们这篇文章，主要介绍Uboot（BL2阶段）的启动流程，BL1阶段启动流程的详细分析，可以见我的后续文章。想要深入了解的，可以好好研究下！
 2.1、程序执行流程图 #  我们先总体来看一下Uboot的执行步骤，这里以EMMC作为启动介质，进行分析！
无论是哪种启动介质，基本流程都相似，我们这就往下看！
==打开图片，结合文档、图片、代码进行理解！==
 2.2、u-boot.lds——Uboot的入口函数 #  u-boot.lds：是uboot工程的链接脚本文件，对于工程的编译和链接有非常重要的作用，决定了uboot的组装，并且u-boot.lds链接文件中的ENTRY(_start)指定了uboot程序的入口地址。
 如果不知道u-boot.lds放到在哪里，可以通过find -name u-boot.lds查找，根目录要进入到uboot的源码的位置哦！
如果查找结果有很多，结合自己的板子信息，确定自己使用的u-boot.lds。
当然，准确的方法是查看Makefile文件，分析出来u-boot.lds所生成的位置。
 在u-boot.lds的文件中，可以看到.text段，存放的就是执行的文本段。截取部分代码段如下：
OUTPUT_FORMAT(&amp;#34;elf32-littlearm&amp;#34;, &amp;#34;elf32-littlearm&amp;#34;, &amp;#34;elf32-littlearm&amp;#34;) OUTPUT_ARCH(arm) ENTRY(_start) SECTIONS { . = 0x00000000;	@起始地址  . = ALIGN(4);	@四字节对齐  .text :	{	*(.__image_copy_start)	@映像文件复制起始地址 *(.vectors)	@异常向量表 arch/arm/cpu/armv7/start.o (.text*)	@启动函数 } ...... }   ENTRY(_start)：程序的入口函数，_start在arch/arm/lib/vectors.S中定义.globl _start
  SECTIONS定义了段，包括text文本段、data数据段、bss段等。
  __image_copy_start在System.</description>
    </item>
    
    <item>
      <title>【一文秒懂】为什么Linux内核中不经常使用typedef</title>
      <link>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88linux%E5%86%85%E6%A0%B8%E4%B8%AD%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8typedef/</link>
      <pubDate>Fri, 19 Jan 2024 21:45:04 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88linux%E5%86%85%E6%A0%B8%E4%B8%AD%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8typedef/</guid>
      <description>为什么 Linux 内核中不经常使用 typedef？ #   我们在进行Linux驱动开发过程中，有没有出现过这样的报错？
WARNING: do not add new typedefs 不允许使用typedef！
虽然只是一个警告，但是如果你想往开源仓库提交代码，这就是一个必优化项。
那么，为什么Linux内核不建议使用typedef呢？
 1、Linus Torvalds 的态度 #    &amp;gt; On Mon, 10 Jun 2002, Linus Torvalds wrote: &amp;gt; &amp;gt; &amp;ndash;snip/snip &amp;gt; &amp;gt; But in the end, maintainership matters. I personally don&amp;rsquo;t want the &amp;gt; &amp;gt; typedef culture to get the upper hand, but I don&amp;rsquo;t mind a few of them, and &amp;gt; &amp;gt; people who maintain their own code usually get the last word.</description>
    </item>
    
    <item>
      <title>【一文秒懂】Linux内核调试工具——Debugfs</title>
      <link>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7debugfs/</link>
      <pubDate>Fri, 19 Jan 2024 21:23:44 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7debugfs/</guid>
      <description>【一文秒懂】Linux内核调试工具——Debugfs #  1、介绍 #  Debugfs其存在的主要意义是为了内核开发者向用户空间传递更多有用的信息，与proc不同，proc只提供进程相关的信息；同时也与sysfs不同，sysfs对每个文件都要求一定的规则，而Debugfs没有任何的规则。
简而言之，Debugfs是一种用于内核调试的虚拟文件系统。
2、如何调试 #  2.1 配置Debugfs #  进去menuconfig选项中，按下/搜索CONFIG_DEBUG_FS关键词即可！
 当然，可以看Location在内核中的位置。
 2.2 挂载Debugfs #  mount -t debugfs none /sys/kernel/debug	#挂载 mount	#查看挂载情况 ___ none on /sys/kernel/debug type debugfs (rw,relatime) 2.3 GPIO调试 #  cat gpio gpio-43 ( |wakeup ) in lo IRQ gpio-64 ( |cd ) in lo IRQ  上述只是简单的调试GPIO的方法，而Debugfs功能远不止于此，其提供了一些API接口，方便我们在内核中Debug使用。
而我们要做的，就是在我们想要进行Debug的地方，注册debugfs接口，然后查看我们要调试的信息。
 2.4 GPIO的实现 #  文件kernel\drivers\gpio\gpiolib.c中
`static const struct file_operations gpiolib_operations = { .</description>
    </item>
    
    <item>
      <title>【MMC子系统】三、MMC子系统框架</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%89mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 19 Jan 2024 21:14:38 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%89mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</guid>
      <description>【MMC子系统】三、MMC子系统框架 #  上章，我们简单了解了EMMC协议，感兴趣的可以查阅一下SD和SDIO的协议，之所以Linux内核能够对SD、SDIO、EMMC进行统一管理，根本原因就是三者协议上的相似性，我们该系列文章均以EMMC为剑，一层层划开包裹着的盔甲。
 本系列文章，均以Linux 4.19为参考
  1、MMC子系统框架 #  如上图所示，MMC子系统的整体框架包括：MMC Host、MMC Core、MMC Block。我们从下网上看：
 MMC HOST：即MMC控制器驱动层，正如其名，该层主要是为了实现MMC控制器的初始化，以及MMC底层的数据收发操作，其直接控制的是底层寄存器，用以产生相应的通信时序。 MMC CORE：即MMC核心层，该层主要起到了承上启下的作用。对下，主要体现在注册MMC总线，实现对MMC device和MMC driver的统一管理；对上，体现在实现MMC通信协议，并向上提供相应的读写操作接口。 MMC BLOCK：即MMC块设备驱动层，其主要作用是屏蔽底层的实现逻辑，将底层抽象为卡设备，并且与虚拟文件系统关联，负责块设备请求的处理以及请求队列的管理，又称为card卡驱动。   哈哈，简单吧，我们刚开始对MMC子系统框架就先了解这么多，不着急，慢慢来。
  2、MMC子系统文件结构 #  了解完MMC子系统后，我们看一下MMC驱动在Linux下的目录结构，我们进入到drivers/mmc目录
drivers/mmc/ ├── core ├── block.c ├── bus.c ├── core.c ├── mmc.c ├── mmc_ops.c ├── ...... ├── host ├── sunxi-mmc.c ├── ......  这里介绍一个方法
 如果刚接触的朋友，不知道文件之间的关系是怎么样的，可以通过Makefile和Kconfig文件来大致看一下。
obj-$(CONFIG_MMC)	+= mmc_core.o mmc_core-y	:= core.o bus.o host.o \ 	mmc.o mmc_ops.</description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】三、一篇文章，带你总览蓝牙协议</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%89%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%80%BB%E8%A7%88%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 19 Jan 2024 21:00:08 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%89%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%80%BB%E8%A7%88%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE/</guid>
      <description>【Bluetooth|蓝牙开发】三、一篇文章，带你总览蓝牙协议 #  1、前言 #  在我们上一章节，学习了蓝牙的基础概念，发展历程，以及常见的蓝牙架构，相信大家对蓝牙也有了一定的了解！
为了更好的去踏入蓝牙开发的大门，蓝牙协议栈是一个我们不得不去跨越的门槛！
 蓝牙协议及其复杂，并非一文能够道尽，本篇文章主要在于对蓝牙整体的协议架构进行梳理，文末官方协议附下载链接。
  2、蓝牙芯片架构 #  蓝牙的核心架构，由一个Host和一个或多个Controller组成。
 BT Host：一个逻辑实体，在HCI（Host Controller Interface）的上层。 BT Controller：一个逻辑实体，在HCI（Host Controller Interface）的下层。  Bluetooth的主控制器，可能是以下几种：
 BR/EDR Controller：内部包含Radio, Baseband，Link Manager，可选的HCI。 LE Controller ：内部包含LE PHY，Link Layer ，可选的HCI BR/EDR &amp;amp; LE Controller ：BR/EDR与LE的组合的控制器 MAC/PHY (AMP) Controller：二级控制器，可替代的，内部包含 802.11 PAL (Protocol Adaptation Layer)，802.11 MAC，PHY，可选的HCI。   根据Host与Controller的组成关系，常见的蓝牙芯片也分为以下几种架构：
 单模蓝牙芯片：单一传统蓝牙的芯片，单一低功耗蓝牙的芯片。即（1个Host结合1个Controller） 双模蓝牙芯片：同时支持传统蓝牙和低功耗蓝牙的芯片。即（1个Host结合多个Controller）  如下图：
 3、蓝牙协议架构——视角1 #  ==上图为官方协议中所提及的图片，由全局到局部来看==
3.1 全局分析 #   由下到上分析</description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】三、硬件驱动层详解</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%89%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 19 Jan 2024 20:27:37 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%89%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/</guid>
      <description>【LED子系统深度剖析】三、硬件驱动层详解 #   上篇文章我们了解了子系统的框架，下面我们来分析驱动框架中每层的实现以及作用。
 在LED子系统中，硬件驱动层相关文件在包括：kernel/drivers/leds/ 目录下，其主要的函数有：led-gpio.c、led-xxx.c，其中led-gpio.c为通用的平台驱动程序，led-xxx.c为不同厂家提供的平台驱动程序。
 我们在这里主要分析led-gpio.c
 1、gpio_led_probe分析 #  打开该文件，直接找到加载驱动的入口函数gpio_led_probe
1.1 相关数据结构 #  1.1.1 gpio_led_platform_data #  struct gpio_led_platform_data { int num_leds; const struct gpio_led *leds; #define GPIO_LED_NO_BLINK_LOW	0	/* No blink GPIO state low */#define GPIO_LED_NO_BLINK_HIGH	1	/* No blink GPIO state high */#define GPIO_LED_BLINK	2	/* Please, blink */ gpio_blink_set_t	gpio_blink_set; }; 结构体名称：gpio_led_platform_data
文件位置：include/linux/leds.h
主要作用：LED的平台数据，用于对LED硬件设备的统一管理
 这个结构体用于父节点向子节点传递的数据时使用
 1.1.2 gpio_leds_priv #  struct gpio_leds_priv { int num_leds; struct gpio_led_data leds[]; }; 结构体名称：gpio_leds_priv</description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】三、原子操作</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 18 Jan 2024 23:02:13 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>【深入理解Linux内核锁】三、原子操作 #  1、原子操作思想 #  原子操作（atomic operation），不可分割的操作。其通过原子变量来实现，以保证单个CPU周期内，读写该变量不能被打断，进而判断该变量的值，来解决并发引起的互斥。
Atomic类型的变量可以在执行期间禁止中断，并保证在访问变量时的原子性。
 简单来说，我们可以把原子变量看作为一个标志位，然后再来检测该标志位的值。
其原子性表现在：操作该标志位的值，不可被打断。
 在Linux内核中，提供了两类原子操作的接口，分别是针对位和整型变量的原子操作。
2、整型变量原子操作 #  2.1 API接口 #   对于整形变量的原子操作，内核提供了一系列的 API接口
 /*设置原子变量的值*/ atomic_t v = ATOMIC_INIT(0); /* 定义原子变量v并初始化为0 */ void atomic_set(atomic_t *v, int i); /* 设置原子变量的值为i */ /*获取原子变量的值*/ atomic_read(atomic_t *v); /* 返回原子变量的值*/ /*原子变量的加减*/ void atomic_add(int i, atomic_t *v); /* 原子变量增加i */ void atomic_sub(int i, atomic_t *v); /* 原子变量减少i */ /*原子变量的自增，自减*/ void atomic_inc(atomic_t *v);	/* 原子变量增加1 */ void atomic_dec(atomic_t *v); /* 原子变量减少1 */ /*原子变量的操作并测试*/ int atomic_inc_and_test(atomic_t *v);	/*进行对应操作后，测试原子变量值是否为0*/ int atomic_dec_and_test(atomic_t *v); int atomic_sub_and_test(int i, atomic_t *v); /*原子变量的操作并返回*/ int atomic_add_return(int i, atomic_t *v);	/*进行对应操作后，返回新的值*/ int atomic_sub_return(int i, atomic_t *v); int atomic_inc_return(atomic_t *v); int atomic_dec_return(atomic_t *v); 2.</description>
    </item>
    
    <item>
      <title>【NVMEM子系统深入剖析】三、核心数据结构及内在关联</title>
      <link>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%89%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%9C%A8%E5%85%B3%E8%81%94/</link>
      <pubDate>Thu, 18 Jan 2024 22:28:56 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%89%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%9C%A8%E5%85%B3%E8%81%94/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>Linux用户态和内核态交互的几种方式</title>
      <link>https://uniondong.github.io/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 17 Jan 2024 21:41:10 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/embeded_tech/embeded_interview/linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>Linux用户态和内核态交互的几种方式 #  Linux分为内核态Kernel Mode和用户态User Mode，其通信方式主要有：
 系统调用System Call：最常见的用户态和内核态之间的通信方式。通过系统调用接口（open、read、write、fork等）请求内核执行特定的动作。 中断Interrupts：中断包括软中断和硬中断，每当中断到来的时候，CPU会暂停当前执行的用户态代码，切换到内核态来处理中断。 信号Signal：内核通过Signal通知用户态进程发生了某些事件，用户态注册信号处理函数，来响应特定的信号事件。如 SIGTERM、SIGINT 等。 共享内存Share Memory：允许多个进程在它们的地址空间中共享一块内存区域，从而实现用户态和内核态之间的高效通信。这种方式避免了用户态和内核态之间频繁切换的问题，但是也需要考虑到数据的同步问题，保证数据一致性。   用户态User Mode访问内核态Kernel Mode的数据交互的方式有：
  procfs进程文件系统：一个伪文件系统，因为其不占用外部存储空间，只占有少量的内存，挂载在/proc目录下
  sysctl：它也是一个Linux命令，主要用来修改内核的运行时参数，也就是在内核运行时，动态修改内核参数。
 和 procfs 的区别在于：procfs 主要是输出只读数据，而 sysctl 输出的大部分信息是可写的。
   sysfs虚拟文件系统：通过/sys来完成用户态和内核的通信，和 procfs 不同的是，sysfs 是将一些原本在 procfs 中的，关于设备和驱动的部分，独立出来，以 “设备树” 的形式呈现给用户。
  netlink 接口：也是最常用的一种方式，本质是socket接口，使用netlink用于网络相关的内核和用户进程之间的消息传递。
  共享内存Share Memory：允许多个进程在它们的地址空间中共享一块内存区域，从而实现用户态和内核态之间的高效数据传输。
   欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>三、Uboot驱动模型</title>
      <link>https://uniondong.github.io/docs/uboot/%E4%B8%89uboot%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 17 Jan 2024 21:28:52 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/uboot/%E4%B8%89uboot%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</guid>
      <description>三、Uboot驱动模型 #   全文耗时一周，精心汇总，希望对大家有所帮助，感觉可以的点赞，关注，不迷路，后续还有更多干货！
看文章前，答应我，静下心来，慢慢品！
 3.1、什么是Uboot驱动模型 #  学过Linux的朋友基本都知道Linux的设备驱动模型，Uboot根据Linux的驱动模型架构，也引入了Uboot的驱动模型（driver model ：DM）。
**这种驱动模型为驱动的定义和访问接口提供了统一的方法。**提高了驱动之间的兼容性以及访问的标准型，uboot驱动模型和kernel中的设备驱动模型类似。
3.2、为什么要有驱动模型呢 #   无论是Linux还是Uboot，一个新对象的产生必定有其要解决的问题，驱动模型也不例外！
  提高代码的可重用性：为了能够使代码在不同硬件平台，不同体系架构下运行，必须要最大限度的提高代码的可重用性。 高内聚，低耦合：分层的思想也是为了达到这一目标，低耦合体现在对外提供统一的抽象访问接口，高内聚将相关度紧密的集中抽象实现。 便于管理：在不断发展过程中，硬件设备越来越多，驱动程序也越来越多，为了更好的管理驱动，也需要一套优秀的驱动架构！  3.3、如何使用uboot的DM模型 #   DM模型的使用，可以通过menuconfig来配置。
make menuconfig
 ①：menuconfig配置全局DM模型 #  Device Drivers -&amp;gt; Generic Driver Options -&amp;gt; Enable Driver Model 通过上面的路径来打开Driver Model模型，最终配置在.config文件中，CONFIG_DM=y
②：指定某个驱动的DM模型 #  全局的DM模型打开后，我们对于不通的驱动模块，使能或者失能DM功能。如MMC驱动为例：
Device Drivers -&amp;gt; MMC Host controller Support -&amp;gt; Enable MMC controllers using Driver Model 最终反映在.config文件中的CONFIG_DM_MMC=y
在对应的驱动中，可以看到判断#if !CONFIG_IS_ENABLED(DM_MMC)，来判断是否打开DM驱动模型。
在管理驱动的Makefile文件中，也能看到obj-$(CONFIG_$(SPL_)DM_MMC) += mmc-uclass.</description>
    </item>
    
    <item>
      <title>三、虚拟地址空间管理</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 17 Jan 2024 21:15:35 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%B8%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</guid>
      <description>Linux内存管理 | 三、虚拟地址空间管理 #  上一节，我们主要了解了虚拟内存空间的布局情况，趁热打铁，我们直接从源代码的视角，来看一下Linux内核是如何管理虚拟内存空间的。
废话不多说，直接开始！
1、用户态空间管理 #  读完上一节我们知道，用户态的布局情况如下：
我们运行的可执行程序，被加载进内存后，会作为一个进程存在，这个进程Linux内核会将其抽象成一个结构体。没错，它就是task_struct。
1.1 task_struct结构体 #  task_struct结构体是进程的抽象，进程所涉及到的内容非常多，下面只列举出一些重要的数据结构，方面理解。
// include/linux/sched.h struct task_struct { ... pid_t	pid;	//	进程PID  pid_t	tgid;	//	线程PID  struct files_struct	*files;	// 进程打开的文件信息  struct mm_struct	*mm;	//	进程虚拟内存空间的内存描述符  ... } 如上，进程抽象为task_struct结构体，通过mm_struct结构体来管理虚拟内存空间。
1.2 mm_struct结构体 #  每个进程都有唯一的 mm_struct 结构体，也就是前边提到的每个进程的虚拟地址空间都是独立，互不干扰的。
mm_struct的结构体如下：
//	include/linux/mm_types.h struct mm_struct { ... struct { ... unsigned long task_size;	/* size of task vm space */ .</description>
    </item>
    
    <item>
      <title>【一文秒懂】Linux内核调试工具——devmem</title>
      <link>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7devmem/</link>
      <pubDate>Fri, 19 Jan 2024 21:23:10 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_debug/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7devmem/</guid>
      <description>【一文秒懂】Linux内核调试工具——devmem #  1、介绍 #  我们在底层开发过程中，经常需要在终端查看或者修改设备寄存器的值，有这样一个工具&amp;mdash;-devmem，可用于读取或者修改物理寄存器的值，非常方便！
简而言之，devmem就是在Linux命令行模式下，直接操作我们设备寄存器的值！
2、如何使用 #  2.1 配置devmem #  进入menuconfig选项中，按下/搜索关键词即可！
2.2、使用devmem #   进入Linux后，输入devmem -h查看帮助信息即可！
 Usage: devmem ADDRESS [WIDTH [VALUE]] Read/write from physical address ADDRESS Address to act upon WIDTH Width (8/16/...) VALUE Data to be written []内部为可选内容，比较简单，这里直接上使用代码！
 读物理内存  devmem 0x10000000	#读指定的物理内存值 devmem 0x10000000 16	#读16bit物理内存的值  写物理内存  devmem 0x10000000 32 0x00000000	#以32bit写入给定的值到指定物理内存 devmem 0x10000000 8 0x010	#以8bit写入给定的值到指定物理内存  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【MMC子系统】四、MMC控制器驱动层</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%9B%9Bmmc%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%B1%82/</link>
      <pubDate>Fri, 19 Jan 2024 21:15:18 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%9B%9Bmmc%E6%8E%A7%E5%88%B6%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%B1%82/</guid>
      <description>【MMC子系统】四、MMC控制器驱动层 #  MMC控制器驱动层一般为chip manufacturer做的事，不同的芯片实现方式不尽相同。
 Linux内核源码，相当大的一部分都是由Device Drivers程序代码组成，其次另一大部分就是那些你从来都没有听说过的Filesystem Format组成，真正核心的代码非常短小精悍的。
 当然，设备驱动程序也有一套既定的框架，按照框架来编写，实现对应的接口就可以了，在这里，我们主要分析一下MMC控制器驱动的实现框架，不拘泥于细节。
 下文以sunxi-mmc.c为例来分析，基于Linux4.19
  4.1 通用驱动框架 #  static int sunxi_mmc_probe(struct platform_device *pdev) { ..... } static const struct of_device_id sunxi_mmc_of_match[] = { { .compatible = &amp;#34;allwinner,sun4i-a10-mmc&amp;#34;, .data = &amp;amp;sun4i_a10_cfg }, { .compatible = &amp;#34;allwinner,sun5i-a13-mmc&amp;#34;, .data = &amp;amp;sun5i_a13_cfg }, { .compatible = &amp;#34;allwinner,sun7i-a20-mmc&amp;#34;, .data = &amp;amp;sun7i_a20_cfg }, { .compatible = &amp;#34;allwinner,sun8i-a83t-emmc&amp;#34;, .data = &amp;amp;sun8i_a83t_emmc_cfg }, { .compatible = &amp;#34;allwinner,sun9i-a80-mmc&amp;#34;, .</description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】四、BLE协议之物理层浅析</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%9B%9Bble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%E6%B5%85%E6%9E%90/</link>
      <pubDate>Fri, 19 Jan 2024 21:00:17 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%9B%9Bble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%E6%B5%85%E6%9E%90/</guid>
      <description>【Bluetooth|蓝牙开发】四、BLE协议之物理层浅析 #  1、前言 #  上文，通过对蓝牙协议框架进行整体了解，其包含BR/EDR((Basic Rate / Enhanced Data Rate))、AMP(Alternate MAC/PHYs)、LE(Low Energy)三种技术，不同技术对应不同的协议栈，本专栏目前对于BLE技术进行详解！
==下面我们将BLE部分单独抽离出来，单独对其进行研究。==
 BLE的协议可分为Bluetooth Application和Bluetooth Core两大部分，而Bluetooth Core又包含BLE Controller和BLE Host两部分。
 快把小本本拿起来，一定要记住！
 我们先从Physical Layer开始分析
2、Physical Channel #  任何一个通信系统，首先要确定的就是通信介质（物理通道，Physical Channel），BLE也不例外。在BLE协议中，“通信介质”的定义是由Physical Layer负责。
Physical Layer是这样描述BLE的通信介质的：
  BLE属于无线通信，则其通信介质是一定频率范围下的频带资源（Frequency Band）
  BLE的市场定位是个体和民用，因此使用免费的ISM频段（频率范围是2.400-2.4835 GHz）
  为了同时支持多个设备，将整个频带分为40份，每份的带宽为2MHz，称作RF Channel。
  经过上面的定义之后，BLE的物理通道划分已经明了了！ $$ 频点(f)=2402(MHz)+k*2(MHz),k=(0&amp;hellip;39) $$ 每个Channel的带宽为2MHz，如下图：
 3、Physical Channel的细分 #  上面我们已经知道了，物理层被划分为了40个赛道，由于传输数据量的不同，为了更加充分利用好物理资源，进一步对通道进行了划分！
40个Physical Channel物理通道分别划分为3个广播通道advertising channel，和37个Data Channel数据通道。
对于数据量少，发送不频繁，时延不敏感的场景，使用广播通道通信。
 例如一个传感器节点（如温度传感器），需要定时（如1s）向处理中心发送传感器数据（如温度）。
针对这种场景，BLE的Link Layer采取了一种比较懒的处理方式&amp;mdash;-广播通信：</description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】四、核心层详解（一）</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%9B%9B%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%80/</link>
      <pubDate>Fri, 19 Jan 2024 20:29:24 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%9B%9B%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%80/</guid>
      <description>【LED子系统深度剖析】四、核心层详解（一） #  1、前言 #   上篇文章我们了解了子系统的硬件驱动层，下面我们来分析驱动框架中核心层的实现以及作用。
 在LED子系统框架中，核心层包括几个部分：核心层的实现部分（led-core.c）、sysfs文件节点创建（led-class.c）、触发功能实现(led-triggers.c、driver/leds/triggers/led-xxx.c)
 其中，触发功能部分较为独立，我们暂且先不去分析。
 我们先从led-class.c文件开始分析
2、leds_init分析 #   该函数其主要是为了创建LED设备文件节点，方便用户通过节点直接访问。
 该文件，我们直接拉下底部，我们直接看入口函数：leds_init
2.1 相关数据结构 #  2.1.1 class #  /** * struct class - device classes * @name:	Name of the class. * @owner:	The module owner. * @class_groups: Default attributes of this class. * @dev_groups:	Default attributes of the devices that belong to the class. * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.</description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】四、自旋锁</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%9B%9B%E8%87%AA%E6%97%8B%E9%94%81/</link>
      <pubDate>Thu, 18 Jan 2024 23:02:41 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%9B%9B%E8%87%AA%E6%97%8B%E9%94%81/</guid>
      <description>【深入理解Linux内核锁】四、自旋锁 #   上两节主要讲解了中断屏蔽和原子操作，这两个作为最底层的操作，几乎在Linux内核中都不单独使用，下面我们来带大家了解一下常用的自旋锁！
 1、什么是自旋锁？ #  自旋锁是一种典型的对临界资源进行互斥访问的手段。
它的底层实现逻辑是：原子变量+判断检测。
原子变量我们可以理解为一把锁，通过操作原子变量（锁）的状态，并对其进行判断，如果锁未被锁定，我们就继续往下执行；如果锁已经被锁定，我们就原地自旋，直到等到锁被打开。
在ARM平台下，自旋锁的实现使用了ldrex、strex、以及内存屏障指令dmb、dsb、wfe、sev等。
2、自旋锁思想 #   自旋锁主要针对于SMP或者单CPU但内核可抢占的情况，对于单CPU内核不可抢占的情况时，自旋锁退化为空操作。 自旋锁实际为忙等锁，当锁不可用时，CPU一直处于等待状态，直到该锁被释放。 自旋锁可能会导致内核死锁，当递归使用自旋锁时，则将该CPU锁死。 在多核SMP的情况下，任何一个核拿到了自旋锁，该核上的抢占调度也暂时禁止了，但是没有禁止另外一个核的抢占调度。 在自旋锁锁定期间，不能调用引起进程调度的函数，如copy_from_user()、copy_to_user()、kmalloc()和msleep()，否则会导致内核崩溃  3、自旋锁的定义及实现 #  3.1 API接口 #  //	定义自旋锁 spinlock_t lock; //	初始化自旋锁 spin_lock_init(&amp;amp;lock) //	获得自旋锁 spin_lock(&amp;amp;lock)	//	获取自旋锁，如果立即获得锁，则直接返回，否则，自旋等待，直到锁被释放 spin_trylock(&amp;amp;lock)	//	尝试获取自旋锁，如果立即获得锁，返回true，否则直接返回false，不原地等待  //	释放自旋锁 spin_unlock(&amp;amp;lock) 自旋锁保证了不受其他CPU或者单CPU内的抢占进程的干扰，但是对于临界区代码，仍然有可能会受到中断和底半部的影响。
为了解决这种问题，我们就要使用自旋锁的衍生。
spin_lock_irq() = spin_lock() + local_irq_disable()	//	获取自旋锁并关中断 spin_unlock_irq() = spin_unlock() + local_irq_enable()	//	释放自旋锁并开中断 spin_lock_irqsave() = spin_lock() + local_irq_save()	//	获取自旋锁并关中断，保存中断状态 spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()//释放自旋锁，开中断并恢复中断状态 spin_lock_bh() = spin_lock() + local_bh_disable()	//	获取自旋锁并关底半部中断 spin_unlock_bh() = spin_unlock() + local_bh_enable()	//	释放自旋锁并发开底半部中断 当我们的临界区代码，有可能被进程或者中断访问时，就需要在进程上下文中，调用spin_lock_irqsave()、spin_unlock_irqrestore()，在中断上下文中调用spin_lock()、spin_unlock()，如下图：</description>
    </item>
    
    <item>
      <title>【NVMEM子系统深入剖析】四、efuse驱动实现流程</title>
      <link>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9Befuse%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Thu, 18 Jan 2024 22:28:17 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_nvmem_subsystem/nvmem%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9Befuse%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>四、Uboot命令行模式分析</title>
      <link>https://uniondong.github.io/docs/uboot/%E5%9B%9Buboot%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 17 Jan 2024 21:31:50 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/uboot/%E5%9B%9Buboot%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</guid>
      <description>四、Uboot命令行模式分析 #   前几篇文章，我们也了解了Uboot的启动流程，那么这节就主要讲讲Uboot的命令行模式。
另外，文章末尾还提供eMMC5.1官方标准协议.pdf和eMMC4.51官方标准协议-中文.pdf下载渠道，方便深入了解底层协议。
正文如下：
  4.1 如何进入命令行模式 #  我们正常启动流程，默认是直接跳过Uboot命令行模式的，因为Uboot主要的作用是引导Kernel，一般我们不进行uboot开发时，都默认跳过进入命令行模式。
 那么，我们要想进入Uboot命令行模式，需要进行哪些配置呢？
 打开我们准备好一份Uboot源码，进入menuconfig配置菜单，主要设置下列几个配置信息！
  CONFIG_CMDLINE：命令行模式开关 CONFIG_SYS_PROMPT：命令行模式提示符 CONFIG_HUSH_PARSER：使用hush shell 来对命令进行解析 BOOTDELAY：设置启动延时   Tip：meneconfig中查找苦难？实时/符号，输入1或2或3，直接查找指定标识。
   打开之后，重新编译，并将Uboot镜像烧录到开发板中，再次启动，我们就能够看到倒计时。
[2022-03-02:13:33:47]U-Boot 2020.10-rc1-00043-ge62a6d17c6-dirty (Feb 08 2022 - 10:14:14 +0800) [2022-03-02:13:33:47] [2022-03-02:13:33:47]Model: xxxxxx [2022-03-02:13:33:47]MMC: mmc1@xxxxxx: 1 [2022-03-02:13:33:47]In: serial [2022-03-02:13:33:47]Out: serial [2022-03-02:13:33:47]Err: serial [2022-03-02:13:33:47]Model: xxxxxx [2022-03-02:13:33:49]Hit any key to stop autoboot: 2 Hit any key to stop autoboot：我们在倒计时结束前，任意键入一个按键，即可进入！
 4.2 Uboot基本命令解析 #  进入Uboot命令行模式后，键入help或者?</description>
    </item>
    
    <item>
      <title>四、物理地址空间设计模型</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 17 Jan 2024 21:15:48 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E5%9B%9B%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</guid>
      <description>Linux内存管理 | 四、物理地址空间设计模型 #  前面几篇文章，主要讲解了虚拟内存空间的布局和管理，下面同步来聊聊物理内存空间的布局和管理。
 1、物理内存 #   什么是物理内存？
 我们平时聊的内存，也叫随机访问存储器（random-access memory），也叫RAM。
RAM分为两类：
 SRAM：静态RAM，其主要用于CPU高速缓存 L1Cache，L2Cache，L3Cache，其特点是访问速度快，访问速度为 1 - 30 个时钟周期，但是容量小，造价高。   DRAM：动态RAM，其主要用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为 50 - 200 个时钟周期，但是容量大，造价便宜些（相对高速缓存）。  DRAM经过组合起来，就作为我们的计算机内存，也是物理内存。
 2、物理内存访问模型 #  上面介绍了物理内存的基本组成，那么CPU是如何访问物理内存的呢？
对于CPU访问物理内存，Linux提供了两种架构：UMA(Uniform Memory Access)一致内存访问，NUMA(Non-Uniform Memory Access)非一致内存访问。
2.1 UMA #  在UMA架构下，多核处理器中的多个CPU，位于总线的一侧，所有的内存条组成的物理内存位于总线的另一侧。
所有的CPU访问内存都要经过总线，并且距离都是一样的，所以在UMA架构下，所有CPU具有相同的访问特性，即对内存的访问具有相同的速度。
2.2 NUMA #  这种架构，系统中的各个处理器都有本地内存，处理器与处理器之间也通过总线连接，以便于其他处理器对本地内存的访问。
与UMA不同的是，处理器访问本地内存的速度要快于对其他处理器本地内存的访问。
3、物理内存组织模型 #  内存页是物理内存管理中最小单位，有时也成为页帧（Page Frame）。
内核对物理内存划分为一页一页的连续的内存块，每页大小4KB，并且使用struct page结构体来表示页结构，其中封装了每个页的状态信息，包括：组织结构，使用信息，统计信息等。
 page结构体较为复杂，我们后续再深入了解。
   更多干货可见：高级工程师聚集地，助力大家更上一层楼！
  3.1 FLATMEM平坦内存模型 #   FLATMEM即：flat memory model。</description>
    </item>
    
    <item>
      <title>【MMC子系统】五、MMC核心层</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%94mmc%E6%A0%B8%E5%BF%83%E5%B1%82/</link>
      <pubDate>Fri, 19 Jan 2024 21:15:35 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%94mmc%E6%A0%B8%E5%BF%83%E5%B1%82/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】五、BLE协议之链路层</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%94ble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Fri, 19 Jan 2024 21:00:55 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%BA%94ble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】五、核心层详解（二）</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%94%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%BA%8C/</link>
      <pubDate>Fri, 19 Jan 2024 20:29:33 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%BA%94%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%BA%8C/</guid>
      <description>【LED子系统深度剖析】五、核心层详解（二） #  1、前言 #   上篇文章我们了解了子系统的核心层led-class.c，下面我们来分析驱动框架中核心层的led-core.c实现以及作用。
 我们接着从led-core.c文件开始分析
2、led_init_core分析 #   上一篇文章，我们知道在将leds_classdev注册进入子系统后，会调用led_init_core函数，初始化核心层，下面我们以led_init_core该函数为突破口分析。
 2.1 相关数据结构 #  2.1.1 work_struct #  struct work_struct { atomic_long_t data; struct list_head entry; work_func_t func; #ifdef CONFIG_LOCKDEP  struct lockdep_map lockdep_map; #endif }; 结构体名称：work_struct
文件位置：include/linux/workqueue.h.h
主要作用：定义一个工作队列，包括了工作项的状态和数据，以及处理工作项的函数指针，用于实现异步执行任务的功能。在工作队列中，每个工作项都是一个work_struct结构体的实例，通过将工作项添加到工作队列中，可以实现后台执行任务的功能。
2.1.2 timer_list #  struct timer_list { /* * All fields that change during normal runtime grouped to the * same cacheline */ struct hlist_node	entry; unsigned long	expires; void	(*function)(struct timer_list *); u32	flags; #ifdef CONFIG_LOCKDEP  struct lockdep_map	lockdep_map; #endif }; 结构体名称：work_struct</description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】五、衍生自旋锁</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%94%E8%A1%8D%E7%94%9F%E8%87%AA%E6%97%8B%E9%94%81/</link>
      <pubDate>Thu, 18 Jan 2024 23:03:11 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%BA%94%E8%A1%8D%E7%94%9F%E8%87%AA%E6%97%8B%E9%94%81/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>五、物理内存空间布局及管理</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 17 Jan 2024 21:16:00 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E4%BA%94%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E5%8F%8A%E7%AE%A1%E7%90%86/</guid>
      <description>Linux内存管理 | 五、物理内存空间布局及管理 #  上章，我们介绍了物理内存的访问内存模型和组织内存模型，我们再来回顾一下：
物理内存的访问内存模型分为：
 UMA：一致内存访问 NUMA：非一致内存访问  物理内存的组织模型：
 FLATMEM：平坦内存模型 DISCONTIGMEM：不连续内存模型 SMARSEMEM：稀疏内存模型  Linux内核为了用统一的代码获取最大程度的兼容性，对物理内存的定义方面，引入了：内存结点（node）、内存区域（zone），内存页（page）的概念，下面我们来一一探究。
 更多干货可见：高级工程师聚集地，助力大家更上一层楼！
  1、内存节点node #  内存节点的引入，是Linux为了最大程度的提高兼容性，将UMA和NUMA系统统一起来，对于UMA而言是只有一个节点的系统。
 下面的代码部分，我们尽可能的只保留暂时用的到的部分，不涉及太多的体系架相关的细节。
 在Linux内核中，我们使用 typedef struct pglist_data pg_data_t表示一个节点
/* * On NUMA machines, each NUMA node would have a pg_data_t to describe * it&amp;#39;s memory layout. On UMA machines there is a single pglist_data which * describes the whole memory. * * Memory statistics and page replacement data structures are maintained on a * per-zone basis.</description>
    </item>
    
    <item>
      <title>【MMC子系统】六、MMC块设备层</title>
      <link>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%ADmmc%E5%9D%97%E8%AE%BE%E5%A4%87%E5%B1%82/</link>
      <pubDate>Fri, 19 Jan 2024 21:15:44 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_mmc_subsystem/mmc%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%85%ADmmc%E5%9D%97%E8%AE%BE%E5%A4%87%E5%B1%82/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】六、BLE协议之传输层</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ADble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
      <pubDate>Fri, 19 Jan 2024 21:01:04 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ADble%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】六、核心层详解（三）</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AD%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%89/</link>
      <pubDate>Fri, 19 Jan 2024 20:43:22 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AD%E6%A0%B8%E5%BF%83%E5%B1%82%E8%AF%A6%E8%A7%A3%E4%B8%89/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】六、信号量</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AD%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Thu, 18 Jan 2024 23:03:31 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AD%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>六、物理内存分配——伙伴系统</title>
      <link>https://uniondong.github.io/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 17 Jan 2024 21:16:10 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_memory_manage/%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</guid>
      <description>Linux内存管理 | 六、物理内存分配——伙伴系统 #  上一章，我们了解了物理内存的布局以及Linux内核对其的管理方式，页（page）也是物理内存的最小单元，Linux内核对物理内存的分配主要分为两种：一种是整页的分配，采用的是伙伴系统，另一种是小内存块的分配，采用的是slab技术。
下面我们先来看看什么是伙伴系统！
 1、伙伴系统（Buddy System） #  Linux系统中，对物理内存进行分配的核心是建立在页面级的伙伴系统之上。Linux内存管理的页大小为4KB，把所有的空闲页分组为11个页块链表，每个链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块，最大可以申请 1024 个连续页，对应 4MB 大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。
如下图所示：
 第 i 个页块链表中，页块中页的数目为 2^i。——仔细理解这个页块的含义。
  在struct zone结构体中，有下面定义
struct free_area	free_area[MAX_ORDER]; #define MAX_ORDER 11 free_area：存放不同大小的页块
MAX_ORDER：就是指数
 当向内核请求分配 (2^(i-1)，2^i] 数目的页块时，按照 2^i 页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。
举个例子：
例如，要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。
 上面的这套机制就是伙伴系统所做的事情，它主要负责对物理内存页面进行跟踪，记录哪些是被内核使用的页面，哪些是空闲页面。
 2、页面分配器（Page Allocator） #  由上一章我们知道，物理内存被分为了几个区域：ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM，其中前两个区域的物理页面与虚拟地址空间是线性映射的。</description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】七、BLE协议之L2CAP</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%83ble%E5%8D%8F%E8%AE%AE%E4%B9%8Bl2cap/</link>
      <pubDate>Fri, 19 Jan 2024 21:01:12 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B8%83ble%E5%8D%8F%E8%AE%AE%E4%B9%8Bl2cap/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】七、触发器实现</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%83%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 19 Jan 2024 20:43:29 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%83%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】七、互斥体</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%83%E4%BA%92%E6%96%A5%E4%BD%93/</link>
      <pubDate>Thu, 18 Jan 2024 23:03:38 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%83%E4%BA%92%E6%96%A5%E4%BD%93/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】八、BLE协议之ATT</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ABble%E5%8D%8F%E8%AE%AE%E4%B9%8Batt/</link>
      <pubDate>Fri, 19 Jan 2024 21:01:21 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%85%ABble%E5%8D%8F%E8%AE%AE%E4%B9%8Batt/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】八、小试牛刀</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AB%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</link>
      <pubDate>Fri, 19 Jan 2024 20:43:38 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%85%AB%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【深入理解Linux锁机制】八、完成量</title>
      <link>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E5%AE%8C%E6%88%90%E9%87%8F/</link>
      <pubDate>Thu, 18 Jan 2024 23:03:45 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_kernel_lock/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E5%AE%8C%E6%88%90%E9%87%8F/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】九、BLE协议——GATT</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B9%9Dble%E5%8D%8F%E8%AE%AEgatt/</link>
      <pubDate>Fri, 19 Jan 2024 21:01:29 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E4%B9%9Dble%E5%8D%8F%E8%AE%AEgatt/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】九、数据结构详解（番外篇）</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B9%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E7%95%AA%E5%A4%96%E7%AF%87/</link>
      <pubDate>Fri, 19 Jan 2024 20:43:46 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B9%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E7%95%AA%E5%A4%96%E7%AF%87/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】十、BLE蓝牙通信流程（建立连接，广播，扫描，断开连接）</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81ble%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%B9%BF%E6%92%AD%E6%89%AB%E6%8F%8F%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Fri, 19 Jan 2024 21:01:39 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81ble%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%B9%BF%E6%92%AD%E6%89%AB%E6%8F%8F%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【LED子系统深度剖析】十、详细实现流程（番外篇）</title>
      <link>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%8D%81%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/</link>
      <pubDate>Fri, 19 Jan 2024 20:43:52 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/linux_led_subsystem/led%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%8D%81%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】十一、超详细的Bluez交叉编译</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%B8%80%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84bluez%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 19 Jan 2024 21:02:02 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%B8%80%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84bluez%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【Bluetooth蓝牙开发】十二、蓝牙调试工具【集合汇总】</title>
      <link>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%BA%8C%E8%93%9D%E7%89%99%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%E6%B1%87%E6%80%BB/</link>
      <pubDate>Fri, 19 Jan 2024 21:02:11 +0800</pubDate>
      
      <guid>https://uniondong.github.io/docs/linux/bluetooth/bluetooth%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%8D%81%E4%BA%8C%E8%93%9D%E7%89%99%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%E6%B1%87%E6%80%BB/</guid>
      <description> 我的圈子：高级工程师聚集地  创作理念：专注分享高质量嵌入式文章，让大家读有所得！  &amp;nbsp; 亲爱的读者，你好：  感谢你对我的专栏的关注和支持，我很高兴能和你分享我的知识和经验。如果你喜欢我的内容，想要阅读更多的精彩技术文章，可以扫码加入我的社群。
  欢迎关注【嵌入式艺术】，董哥原创！  </description>
    </item>
    
    <item>
      <title>【10W&#43;阅读】耗时一周总结的嵌入式学习路线，超详细</title>
      <link>https://uniondong.github.io/docs/embeded_tech/self_improve/10w&#43;%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/</link>
      <pubDate>Sat, 04 Nov 2023 16:30:00 +0000</pubDate>
      
      <guid>https://uniondong.github.io/docs/embeded_tech/self_improve/10w&#43;%E9%98%85%E8%AF%BB%E8%80%97%E6%97%B6%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E8%B6%85%E8%AF%A6%E7%BB%86/</guid>
      <description>【10W+阅读】耗时一周总结的嵌入式学习路线，超详细 #  人们常说：“人生就是一场场游戏，我们要做的，就是打怪，升级，通关”，学习嵌入式的过程也是如此。
1、前言 #  最近看到知乎上，给我推送了很多类似的回答，借此机会，也想着重新审视一下自己的学习历程，以及结合自身和大牛，分享一些学习经验，希望对大家有所启发和帮助。
本文主要目的是为了：
 提供一张嵌入式学习路线地图 提供不同阶段的学习建议 推荐不同阶段的学习资料  3000余字，耗时1周，建议收藏；码字不易，如有帮助，慷慨三连
 本文将嵌入式学习路线分为几个方面：
 嵌入式基础必备知识 51单片机 STM32单片机 小而美的RTOS ARM+LINUX   在这个快节奏的时代，能静下心，耐住性子看看文章，实属不易。
  2、嵌入式基础必备知识 #  老子曰：“合抱之木，生于毫末：九层之台，起于垒土；千里之行，始于足下”，根基的重要性不言而喻。
那么对于嵌入式这条路线而言，如何建立一个稳固的根基？
 2.1、学习内容 #   C语言基础  该部分，主要包括几个核心知识点：三大语法结构、常用的数据类型、函数、结构体、指针、文件操作等。
 硬件基础知识  该部分，核心知识点在于：电路基础知识、数电模电基础知识、常用的电子元器件等。
 数据结构  核心知识点：数组、队列、链表、堆栈、树、图、散列表等。
 操作系统  核心知识点：进程管理、内存管理、文件管理、输入输出管理等。
 计算机原理  核心知识点：数据表示和运算、存储系统、指令系统、总线系统、中央处理器、输入输出系统等。
 2.2、学习建议 #   对于C语言基础学习，一定要重点熟练掌握，根基的牢固直接决定了我们的代码质量。 对于硬件基础学习，要适当了解，要能够看懂一些简单的电路结构，认识常用的电子元器件。 对于数据结构学习，前五个是必备学习的，可能在刚开始学习的时候，可能会感觉不到作用在哪里，但是随着接触到嵌入式底层设计以及算法设计的时候，才会恍然大悟。 对于操作系统学习，重点学习其思想，对相关知识点有一个大概的了解，后续接触到继续重点学习，这些无论是RTOS，还是Linux，都有涉及到的。 对于计算机原理学习，可以将其看作是嵌入式系统的各个模块的详解，会让你对嵌入式有一个整体的了解，每一个部分都值得深究。   2.3、学习资料 #   C语言基础：推荐经典书籍**《C语言程序设计》（第2版）谭浩强版本**。 硬件基础：大学里面的《数电模电》书籍所涉及的知识即可。 数据结构：推荐经典书籍**《数据结构》——严蔚敏版**。 操作系统、计算机原理：我用的是**《王道》的系列丛书**，个人感觉不错。  计算机组成、数据结构、操作系统、数据库是嵌入式或者说计算机的入门必读书籍，并且也被列入高校教材内，是真正的基础知识。</description>
    </item>
    
  </channel>
</rss>
